<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="喵十八の小窝">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="喵十八の小窝">
<meta property="og:locale">
<meta property="article:author" content="喵十八">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>喵十八の小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">喵十八の小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/ReMarkov/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/29/ReMarkov/" class="post-title-link" itemprop="url">【翻译活动】面向数据科学的概率论-11.反转马尔科夫链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-29 17:54:27" itemprop="dateCreated datePublished" datetime="2018-07-29T17:54:27+08:00">2018-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-08-05 19:32:23" itemprop="dateModified" datetime="2018-08-05T19:32:23+08:00">2018-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<a href="https://nbviewer.jupyter.org/github/prob140/textbook/blob/gh-pages/notebooks/Chapter_11/">prob140/textbook/notebooks/ch_11</a></p>
<p>译者：<a href="https://github.com/Yao544303">喵十八</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/">谷歌翻译</a></p>
</blockquote>
<h1 id="本章所需python包"><a href="#本章所需python包" class="headerlink" title="本章所需python包"></a>本章所需python包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="keyword">from</span> datascience <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> prob140 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">&#x27;fivethirtyeight&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> misc</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="keyword">from</span> datascience <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> prob140 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">&#x27;fivethirtyeight&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> misc</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="comment"># The alphabet</span></span><br><span class="line">alph = make_array(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="comment"># Decode atdt using all possible decoders</span></span><br><span class="line">x1 = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;t&#x27;</span>], [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>]]</span><br><span class="line">x2 = [[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], [<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]]</span><br><span class="line">decoded = x1+x2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line">decoding = Table().with_columns(</span><br><span class="line">    <span class="string">&#x27;Decoder&#x27;</span>, <span class="built_in">list</span>(permutations(alph)),</span><br><span class="line">    <span class="string">&#x27;atdt Decoded&#x27;</span>, decoded</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="comment"># Make bigram transition matrix</span></span><br><span class="line"><span class="comment"># Data from Peter Norvig&#x27;s bigram table</span></span><br><span class="line"></span><br><span class="line">aa = <span class="number">1913489177</span></span><br><span class="line">dd = <span class="number">6513992572</span></span><br><span class="line">tt = <span class="number">19222971337</span></span><br><span class="line">ad = <span class="number">23202347740</span></span><br><span class="line">da = <span class="number">23279747379</span></span><br><span class="line">at = <span class="number">80609883139</span></span><br><span class="line">ta = <span class="number">42344542093</span></span><br><span class="line">dt = <span class="number">10976756096</span></span><br><span class="line">td = <span class="number">3231292348</span></span><br><span class="line"></span><br><span class="line">row1 = make_array(aa, ad, at)/<span class="built_in">sum</span>([aa, ad, at])</span><br><span class="line">row2 = make_array(da, dd, dt)/<span class="built_in">sum</span>([da, dd, dt])</span><br><span class="line">row3 = make_array(ta, td, tt)/<span class="built_in">sum</span>([ta, td, tt])</span><br><span class="line">rows = np.append(np.append(row1, row2), row3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line">bigrams = MarkovChain.from_table(Table().states(alph).transition_probability(rows))</span><br></pre></td></tr></table></figure>
<h1 id="反转马尔科夫链"><a href="#反转马尔科夫链" class="headerlink" title="反转马尔科夫链"></a>反转马尔科夫链</h1><p>股票市场，变异病毒和计算机搜索引擎有什么共同之处？他们都使用马尔可夫链模型进行了分析。了解马尔可夫链的长期行为有助于我们理解许多不同的随机现象。</p>
<p>在数据科学中，马尔可夫链也用于完全不同的目的。马尔科夫链帮助数据科学家从对于标准采样方法来说太复杂的分布中抽取随机样本。马尔可夫链也可用于分布非常复杂或使用标准方法难以估计的未知量的近似值预估。这可以通过创建马尔可夫链来实现，该马尔可夫链具有作为其稳态分布的原型分布，然后长时间运行链直到它接近稳态。该方法称为马尔科夫链-蒙特卡洛法（Markov Chain Monte Carlo），缩写为MCMC。令人惊讶的是，它涉及了解马尔可夫链反向运行时会发生什么，也就是说当它们被<em>反转</em>时会发生什么。</p>
<p>要理解和实现MCMC算法，您必须研究马尔可夫链的可逆性并进行计算。在本章和随附的实验中，我们将简要介绍这一领域。</p>
<h2 id="详细的平衡"><a href="#详细的平衡" class="headerlink" title="详细的平衡"></a>详细的平衡</h2><p>我们一直在研究的马尔可夫链具有稳态分布，其中包含有关链的行为的大量信息。链的稳态分布是平衡方程的解。对于某些链，很容易得到平衡方程的解。但对于其他链条，求解过程可能很复杂或乏味。让我们看看我们是否能找到一种简单的方法来求解平衡方程。</p>
<p>回想一下我们早先关于方程中平衡态的描述。想象一下链的大量独立复制。例如，假设根据链的转移概率，大量粒子在状态间转移，所有粒子在时刻1, 2, 3, $\ldots$的转移都是相对独立的。</p>
<p>假设链处于稳态。正如我们之前所说，设$\pi(k)$为任意时刻离开状态$k$的粒子，那么平衡方程为</p>
<script type="math/tex; mode=display">
\pi(j) = \sum_{k \in S} \pi(k)P(k, j)</script><p>当离开状态$j$和进入它的粒子相同时，称链为平衡的。</p>
<p>请注意，左侧只是离开$j$的粒子的比例; 没有关于粒子去向的信息。</p>
<p>现在假设有<em>详细的平衡</em>，由下式给出</p>
<script type="math/tex; mode=display">
\pi(i)P(i, j) = \pi(j)P(j, i) ~~~ \text{for all states } i \ne j</script><p>这些被称为<em>详细平衡方程</em>。表示对于每一对状态$i$和$j$，离开状态 $i$进入状态$j$的粒子数量和离开状态$j$进入状态$i$的粒子数量一致。在状态$i = j$的情况下，方程无意义，因此被排除在外。</p>
<p>结果证明这是一个比平衡方程更强的条件。</p>
<h3 id="详细平衡意味着平衡"><a href="#详细平衡意味着平衡" class="headerlink" title="详细平衡意味着平衡"></a>详细平衡意味着平衡</h3><p>假设存在概率分布 $\pi$ 是详细平衡方程的解，那么$\pi$必然也是平衡方程的解。</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{k \in S} \pi(k)P(k, j) &= \sum_{k \in S} \pi(j)P(j, k)  \text{(详细平衡方程)} \\
&= \pi(j) \sum_{k \in S} P(j, k) \\
&= \pi(j) \cdot 1  \text{(转移矩阵}j\text{th 行的和)} \\
&= \pi(j)
\end{align*}</script><p>我们从中学到的是，如果我们能够求解详细平衡方程，那么我们也能求解平衡方程。</p>
<p>这有两个原因：</p>
<ul>
<li>详细的平衡方程很简单。</li>
<li>详细平衡方程的数量很多，如果有$s$个状态，那么有$\binom{s}{2}$ 个详细平衡方程，包含$s$个未知变量。这为我们提供了许多尝试解决它们的方法。</li>
</ul>
<p>当然，所有这些$\binom{s}{2}$方程不是必须保持一致的，在这种情况下，这些平衡方程无解。在这种情况下，我们只能直接求解平衡方程。这里有一个例子表明，如果详细的平衡方程确实有解，我们就可以轻松地得到链的稳态分布。</p>
<h3 id="爱伦菲斯特链"><a href="#爱伦菲斯特链" class="headerlink" title="爱伦菲斯特链"></a>爱伦菲斯特链</h3><p>我们需要回到这个例子，因为它可以通过一些操作来求解平衡方程。我们将展示对于这个链和其他类似的链中，如何简便的求解详细的平衡方程，这为我们提供了一个快速求的稳态分布的途径。</p>
<p>状态空间是整数0到$N$。回想一下转移是如何进行的：在每一步，链条向前转移1个状态，保持不变，或者向后转移1个状态。这些链称为<em>生死</em>链，用于模拟许多随机模型，如赌徒的命运或人口规模。在我们的例子中，模拟了容器中气体粒子的数量。</p>
<p>对于这样的链，1-阶转移矩阵中，大多数转移概率是0，因为在一个步骤中链只能移动到两个相邻状态。所以大多数详细的平衡方程都是正确的。对于那些1-阶转移概率为正的两个状态$i$和$j$，两者之间的间隔必为1。（注意，详细平衡方程指定$i \ne j$）。在那种情况下，由于链不可约，$P(i, j)$和$P(j, i)$都为正。</p>
<p>这允许我们从最低状态开始向上移动来求解详细平衡方程。记住转移规则：</p>
<ul>
<li>在每个步骤中，从$N$中随机选取一个粒子，随意放入两个容器中的一个; 链计算容器1中的粒子数。</li>
</ul>
<p>详细的平衡方程式可以顺序求解：</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(0)\frac{1}{2} &= \pi(1)\frac{1}{2N} ~~ \implies ~~ \pi(1) = N\pi(0)
= \binom{N}{1}\pi(0) \\ \\
\pi(1)\frac{N-1}{2N} &= \pi(2)\frac{2}{2N} ~~ \implies ~~ \pi(2) = \frac{N-1}{2}\pi(1) = \frac{N(N-1)}{2}\pi(0) = \binom{N}{2}\pi(0) \\ \\
\pi(2)\frac{N-2}{2N} &= \pi(3)\frac{3}{2N} ~~ \implies ~~ \pi(3) = \frac{N-2}{3}\pi(2) = \frac{N(N-1)(N-2)}{3\cdot 2} \pi(0) = \binom{N}{3}\pi(0)
\end{align*}</script><p>等，从而对于$1 \le k \le N$,有</p>
<script type="math/tex; mode=display">
\pi(k) = \binom{N}{k} \pi(0)</script><p>通过比，归纳比求解平衡方程更容易。各项总和为</p>
<script type="math/tex; mode=display">
\pi(0)\big{(} 1 + \sum_{k=1}^N \binom{N}{k} \big{)}
= \pi(0)\sum_{k=0}^N \binom{N}{k}
= \pi(0)2^N</script><p>由二项式定理。所以$\pi(0) = 2^{-N}$并且稳态分布为二项分布$(N, 1/2)$.</p>
<p>在这一点上，值得记住的是对于数值 $N$，你可以使用<code>steady_state</code>来找到稳态分布。依靠Python来为你做所有的工作。这有一些明显的优点，但也有一些缺点：</p>
<ul>
<li>当$N$非常大时，Python无法处理计算。</li>
<li>你会看到分布是二项分布，但不知道是怎么得来的。</li>
</ul>
<p>这就是为什么即使在强大的个人计算机时代，找到使用数学解决问题的好方法仍然很重要。</p>
<h3 id="环形粘性随机漫步"><a href="#环形粘性随机漫步" class="headerlink" title="环形粘性随机漫步"></a>环形粘性随机漫步</h3><p>假设一个链在圆上顺时针顺序排列状态0,1,2,3,4。假设在每个步骤中保持在原位的概率为$s$，移动到逆时针邻居的概率为$p$，移动到顺时针邻居的概率为$r$。这里，$s$, $p$和 $r$都为正，且总和为1。</p>
<p>很明显，链的行为在五个状态中是对称的，因此从长远来看，预计在每个状态中花费的时间占比相同。状态上的稳态分布是均匀的。您也可以通过求解平衡方程来校验这一点。</p>
<p>让我们看看上述链是否满足详细的平衡方程。与上面的Ehrenfest链不同，这条链可以“环回”。所以不清楚是否满足详细的平衡方程。</p>
<p>详细的平衡方程是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(0)r = \pi(1)p ~~~~ \implies \pi(1) = \frac{r}{p}\pi(0) \\ 
\pi(1)r = \pi(2)p ~~~~ \implies \pi(2) = \frac{r^2}{p^2}\pi(0) \\ 
\pi(2)r = \pi(3)p ~~~~ \implies \pi(3) = \frac{r^3}{p^3}\pi(0) \\ 
\pi(3)r = \pi(4)p ~~~~ \implies \pi(4) = \frac{r^4}{p^4}\pi(0) 
\end{align*}</script><p>到目前为止一切都那么好，现在到了求解真相的关键：</p>
<script type="math/tex; mode=display">
\pi(4)r = \pi(0)p ~~~~ \implies \pi(4) = \frac{p}{r}\pi(0)</script><p>对于这个方程组，有解的前提是$\pi(4)$的两个表达式必须相等，也就是</p>
<script type="math/tex; mode=display">
\frac{r^4}{p^4} = \frac{p}{r}, ~~~ \text{that is, } ~r^5 = p^5</script><p>这只有在$r = p$时才会发生，在这种情况下，详细的平衡方程表示$\pi$ 的所有条目都是相等的，而这是已知的。</p>
<p>总结一下：</p>
<ul>
<li>在所有状态下，链的稳态分布是均匀的。均匀分布满足平衡方程。</li>
<li>当$r = p$, 详细的平衡方程有一个正解，即稳态分布。</li>
<li>当$r \ne p$详细的平衡方程没有概率分布作为解。</li>
</ul>
<p>显然，$r = p$ 有特殊的地位。这究竟对这个链的行为意味着什么？这是下一节的主题。目前，这里用于模拟链路径的两组参数：</p>
<ul>
<li><code>circle_walk_1</code>: $s = 0.1$, $r = 0.6$, $p = 0.3$</li>
<li><code>circle_walk_2</code>: $s = 0.1$, $r = 0.3$, $p = 0.6$</li>
</ul>
<p>保持原位的机会对于两者都是相同的，但顺时针和逆时针移动的机会已经切换。这是两条链的模拟路径。在图中，“顺时针”显示为向上移动，“逆时针”显示为向下移动。</p>
<p>查看路径（如果您愿意，可以模拟更多路径）并回答以下问题：</p>
<ul>
<li>哪一个有“向上”转移而不是“向下”？</li>
<li>如果有人向您展示了这两个流程之一的路径，但没有说明这两个流程中的哪一个，您能否确定是哪一个？</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">states = np.arange(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="number">0.1</span></span><br><span class="line">r = <span class="number">0.6</span></span><br><span class="line">p = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transition_prob</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> i == j:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">elif</span> j == (i+<span class="number">1</span>) % <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">elif</span> j == (i-<span class="number">1</span>) % <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">circle_walk_1 = MarkovChain.from_transition_function(states, transition_prob)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk_1</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.1</td>
      <td>0.6</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.3</td>
      <td>0.1</td>
      <td>0.6</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>0.3</td>
      <td>0.1</td>
      <td>0.6</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.3</td>
      <td>0.1</td>
      <td>0.6</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.6</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.3</td>
      <td>0.1</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk_1.simulate_path(<span class="number">0</span>, <span class="number">50</span>, plot_path=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/prob140/11-1-output_8_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0.1</span></span><br><span class="line">r = <span class="number">0.3</span></span><br><span class="line">p = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line">circle_walk_2 = MarkovChain.from_transition_function(states, transition_prob)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk_2</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.1</td>
      <td>0.3</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.6</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.6</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>0.6</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.6</td>
      <td>0.1</td>
      <td>0.3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.3</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.6</td>
      <td>0.1</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk_2.simulate_path(<span class="number">0</span>, <span class="number">50</span>, plot_path=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/prob140/11-2-output_11_0.png" alt="png"></p>
<h2 id="可逆性"><a href="#可逆性" class="headerlink" title="可逆性"></a>可逆性</h2><p>前一部分的随机漫步在环上顺时针顺序排列的状态0,1,2,3,4。在每个步骤中保持在原位的概率为$s$，移动到逆时针邻居的概率为$p$，移动到顺时针邻居的概率为$r$。链的稳态分布为每个状态的概率为0.2。</p>
<p>若$r &gt; p$, 那么链更可能顺时针方向而不是逆时针方向移动。例如，在稳态下，路径$0, 1, 2, 3$的概率为：</p>
<script type="math/tex; mode=display">
P(X_0 = 0)P(0, 1)P(1, 2)P(2, 3) = 0.2r^3</script><p>所述路径的<em>反转路径</em> $3, 2, 1, 0$ 的概率为</p>
<script type="math/tex; mode=display">
P(X_0 = 3)P(3, 2)P(2, 1)P(1, 0) = 0.2p^3</script><p>若 $r &gt; p$，那么原始路径的概率更高。</p>
<p>但如果$r = p$，那么原始路径与反向路径的概率相同; 在稳定状态下，链条可能朝任何一个方向上运行。如果某人在稳定状态下模拟链并向您显示原始路径以及反向路径，您将无法分辨哪个是哪个。</p>
<p>在本节中，我们将定义马尔科夫链以这种方式<em>可逆</em>的意义。</p>
<h3 id="反转过程"><a href="#反转过程" class="headerlink" title="反转过程"></a>反转过程</h3><p>设$X_0, X_1, \ldots $是一个定义在有限状态空间下，具有稳态分布$\pi$的不可约马尔可夫链。以这种稳态分布启动该链，也就是说，让$X_0$具有分布$\pi$。然后对于所有的$n \ge 1$，$X_n$的分布也是$\pi$。</p>
<p>修正，令$n &gt; 0$，并考虑<em>反向</em>序列$Y<em>0, Y_1, \ldots, Y_n$，其中$Y_k = X</em>{n-k}$， $k = 0, 1, \ldots, n$。称$X_0, X_1, \ldots, X_n$为<em>正向</em>序列。</p>
<p>反向序列是时间同质马尔可夫链的一个很好实例。为了了解原因，我们将检查马尔科夫性质是否成立。</p>
<p>在我们证明一般事实之前，让我们进行一些探索性的计算。从$n = 1$开始，此时有$Y_0 = X_1$ 和$Y_1 = X_0$。对于状态$i$和$j$。</p>
<script type="math/tex; mode=display">
\begin{align*}
P(Y_1 = j \mid Y_0 = i) ~ &= ~ \frac{P(Y_1 = j, Y_0 = i)}{P(Y_0 = i)} \\
&= ~ \frac{P(X_0 = j, X_1 = i)}{P(X_1 = i)} \\
&= ~ \frac{\pi(j)P(j, i)}{\pi(i)}
\end{align*}</script><p>因为正向序列处于稳定状态。我们已经使用转移矩阵和前向序列的稳态分布找到了反向序列的转移概率。</p>
<p>对于$n = 2$，我们有$Y_0 = X_2$，$Y_1 = X_1$， 和 $Y_2 = X_0$。对于状态$k$，$i$，和$j$</p>
<script type="math/tex; mode=display">
\begin{align*}
P(Y_2 = j \mid Y_0 = k, Y_1 = i) ~ &= ~ \frac{P(Y_2 = j, Y_1 = i, Y_0 = k)}{P(Y_1 = i, Y_0 = k)} \\
&= ~ \frac{P(X_0 = j, X_1 = i, X_2 = k)}{P(X_1 = i, X_2 = k)} \\
&= ~ \frac{\pi(j)P(j, i)P(i, k)}{\pi(i)P(i, k)} \\
&= ~ \frac{\pi(j)P(j, i)}{\pi(i)}
\end{align*}</script><p>解不依赖于$k$。这与马尔科夫性质保持一致。另外结合我们刚刚证明的两个事实，可以发现，转移概率是时间同质的。</p>
<p>对于更一般的$n$，修正状态$i$和$j$以及 0到$n-1$之间的整数$m$有</p>
<script type="math/tex; mode=display">
\begin{align*}
& P(Y_{m+1} = j \mid Y_0 = i_0, Y_1 = i_1, \ldots, Y_{m-1} = i_{m-1}, Y_m = i) \\ \\ 
&=
\frac{P(Y_0 = i_0, Y_1 = i_1 \ldots, Y_{m-1} = i_{m-1}, Y_m = i, Y_{m+1} = j)}
{P(Y_0 = i_0, Y_1 = i_1 \ldots, Y_{m-1} = i_{m-1}, Y_m = i)} \\ \\
&= \frac{P(X_n = i_0, X_{n-1} = i_1, \ldots, X_{n-m+1} = i_{m-1}, X_{n-m} = i, X_{n-m-1} = j)}
{P(X_n = i_0, X_{n-1} = i_1, \ldots, X_{n-m+1)} = i_{m-1}, X_{n-m} = i)} \\ \\
&= \frac{\pi(j)P(j, i)P(i, i_{m-1}) \cdots P(i_1, i_0)}
{\pi(i)P(i, i_{m-1}) \cdots P(i_1, i_0)} \\ \\
&= \frac{\pi(j)P(j, i)}{\pi(i)}
\end{align*}</script><p>这只涉及状态$i$和$j$，而和$i<em>0, i_1, \ldots, i</em>{m-1}$以及$m$无关。因此满足马尔可夫性质，转移概率是时间同质的。反向序列”状态$i$到状态$j$”的1-阶转移概率为</p>
<script type="math/tex; mode=display">
P(Y_1 = j \mid Y_0 = i) = \frac{\pi(j)P(j, i)}{\pi(i)}</script><h3 id="可逆链"><a href="#可逆链" class="headerlink" title="可逆链"></a>可逆链</h3><p>当原来的<em>正向</em>马尔科夫链$X_0, X_1, \ldots $中，对于每个$n$，其反向序列$Y_0, Y_1, \ldots Y_n$<em>的1-阶转移概率和原始序列一样</em>的情况，被称作是<em>可逆的</em>。也就是说</p>
<script type="math/tex; mode=display">
\frac{\pi(j)P(j, i)}{\pi(i)} = P(i, j) ~~~ \text{for all } i, j</script><p>如果链可逆，则有</p>
<script type="math/tex; mode=display">
\pi(i)P(i, j) = \pi(j)P(j, i) ~~~ \text{for all } i, j</script><p>换言之：</p>
<p><strong>如果详细的平衡方程具有正解，则链是可逆的。</strong> 这与我们在稳状下根据该链想象粒子的移动情况一致：在每个时刻，对于每一对状态$i$和$j$，粒子从$i$移动到$j$的比例与从$j$移动到$i$的比例完全相同。</p>
<p>在本节开始时，我们查看了一个环上的随机漫步。让我们看看可逆性的定义对于这个链是什么意思。</p>
<ul>
<li><p>在上一节中，我们展示了当 $p \ne r$时，详细的平衡方程没有正解。因此，当 $p \ne r$时，链条是不可逆的。这与我们之前的分析一致。</p>
</li>
<li><p>当$p = r$时，我们找到了详细平衡方程的解，因此链是可逆的。这形式化了我们的猜想，即如果$p = r$，那么在稳态下，链条“正向或者反向运行是一样的”。</p>
</li>
</ul>
<h3 id="生死链的可逆性"><a href="#生死链的可逆性" class="headerlink" title="生死链的可逆性"></a>生死链的可逆性</h3><p>回想一下，<em>生死链</em>是定义在整数上的马尔可夫链，其每一步的转移限制为增加1，减少1或者保持不变。不难校验具有有限状态空间的不可约的生死链是否可逆。您可以像我们在上一节中对Ehrenfest链所做的那样，通过求解详细的平衡方程来校验。</p>
<p>返回并查看文本和练习中的示例。切换链，反射随机漫步（包括懒惰和非懒惰的），Ehrenfest链和伯努利 - 拉普拉斯链都是不可简约的生死链，因此都是可逆的。</p>
<p>让我们在乍一看似乎不可逆转的生死链的情况下证实这一点。这是马尔可夫链 $X_0, X_1, \ldots $的转移图。</p>
<p><img src="/image/prob140/11-3-trans_b_and_d.png" alt="B&amp;D"></p>
<p>这条链以较高的概率向右移动（即生有孩子），所以看起来好像我们应该知道它是正向还是反向移动。但请记住，<em>时间逆转发生在稳态</em>。在稳态下，链条可能在状态3和4之间穿梭。您可以通过求解详细的平衡方程式来看到这一点。</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(1)\cdot 1 &= \pi(2) \cdot 0.1 ~~~~ \implies \pi(2) = 10\pi(1)  \\
\pi(2) \cdot 0.9 &= \pi(3) \cdot 0.1 ~~~~ \implies \pi(3) = 90\pi(1) \\
\pi(3) \cdot 0.9 &= \pi(4) \cdot 1 ~~~~~~~ \implies \pi(4) = 81\pi(1)
\end{align*}</script><p>它也将访问状态2和1，但很少，状态1特别罕见。这些访问将散布3和4中，并且这些路径将无法区分正向和反向移动。</p>
<p>让我们模拟这个过程的路径。首先，我们构造转移矩阵并确认我们$\pi$的计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s = np.arange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> j == i+<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.9</span></span><br><span class="line">    <span class="keyword">elif</span> j == i-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">bnd = MarkovChain.from_transition_function(s, trans)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = bnd.steady_state()</span><br><span class="line">pi</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Value</th> <th>Probability</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1    </td> <td>0.00549451 </td>
        </tr>
    </tbody>
        <tr>
            <td>2    </td> <td>0.0549451  </td>
        </tr>
    </tbody>
        <tr>
            <td>3    </td> <td>0.494505   </td>
        </tr>
    </tbody>
        <tr>
            <td>4    </td> <td>0.445055   </td>
        </tr>
    </tbody>
</table>



<p>我们可以使用<code>simulate_path</code>来绘制链的路径。请注意，与我们以前使用此方法不同，我们现在将初始分布作为第一个参数传递，而不是特定状态。第二个参数是步骤数，如前所述。</p>
<p>下图显示了一条长度为200的路径。运行单元格几次，并向前和向后查看每条路径。你不会发现两者之间的系统差异。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">n = <span class="number">200</span>                          <span class="comment"># the number of steps</span></span><br><span class="line">x = np.arange(n+<span class="number">1</span>)               <span class="comment"># the steps</span></span><br><span class="line">y = bnd.simulate_path(pi, n, plot_path=<span class="literal">True</span>)    <span class="comment"># the simulated state at each step</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Axis labels and title</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;$n$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$X_n$&#x27;</span>, rotation=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Reversibility: Path of Birth and Death Chain in Steady State&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/image/prob140/11-4-output_11_0.png" alt="png"></p>
<h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><p>有趣的是，虽然许多马尔可夫链是可逆的，但到目前为止我们看到的例子并没有解释我们通过反转链条得到的结果。毕竟，如果它看起来像正向一样向前运行，为什么不向前运行呢？为什么要担心可逆性呢？</p>
<p>事实证明，逆转马尔可夫链可以帮助解决其他方法难以处理的一类问题。在本节中，我们将介绍如何出现此类问题的示例。在下一节中，我们将讨论一个解决方案。</p>
<h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>在网络安全成为我们生活的一部分之前，人们就已经对加密和解密非常感兴趣了。解码加密信息可能是复杂且计算密集的。逆转马尔可夫链可以帮助我们完成这项任务。</p>
<p>为了了解解决此类问题的方法以及问题的涉及范围，让我们尝试解码使用称为<em>替代代码</em>的简单代码加密的一小段文本。文本以字母表写，您可以将其视为一组字母和标点符号。在替换代码中，字母表中的每个字母简单地被另一个字母替换，使得代码只是字母表的排列。</p>
<p>要解码由替换代码加密的消息，您必须<em>反转</em>使用的排列。换句话说，您必须对<em>编码</em>消息应用置换以恢复原始文本。我们将这个置换称为<em>解码器</em>。</p>
<p>要解码文本消息，我们必须做出一些假设。例如，了解编写消息的语言，以及该语言中常见的字母组合。具体而言，就假设我们尝试解码用英语编写然后加密的消息。如果我们的解码过程以zzxtf和tbgdgaa之类的“单词”结束，我们可能想尝试不同的方式。</p>
<p>所以我们需要关于哪些字母序列是常见的数据。这些数据现在越来越容易收集; 例如由 <a href="http://norvig.com">Peter Norvig</a>, 一个谷歌的研究总监负责的<a href="http://norvig.com/ngrams/">网页</a></p>
<h3 id="解码信息"><a href="#解码信息" class="headerlink" title="解码信息"></a>解码信息</h3><p>让我们看看我们如何使用这种方法来解码消息。为简单起见，假设我们的字母表只包含三个字母a，d和t。现在假设我们得到编码消息atdt。我们相信这是一个英文单词。我们怎么能以一种可以被计算机重复的方式来解码呢？</p>
<p>作为第一步，我们将记下所有3！= 6个字母表中字母的可能排列，并使用每个字母对消息进行解码。该表<code>decoding</code>包含所有结果。<code>Decoder</code>中的每个条目都是一个排列，我们将应用于我们的编码文本atdt。确定我们将在解码过程中对哪些字母置换。</p>
<p>要了解如何执行此操作，请首先将字母“按字母顺序”的排序：’a’，’d’，’t’。现在看一下表格的行。</p>
<ul>
<li><p>第一行中的解码器是[‘a’，’d’，’t’]。这个解码器简单地保持字母不变; atdt被解码为atdt。 </p>
<script type="math/tex; mode=display">
\text{Decoder ['a', 'd', 't']: } ~~~ a \to a, ~~~ d \to d, ~~~ t \to t</script></li>
<li><p>第二行中的解码器是[‘a’，’t’，’d’]。这使得字母’a’的第一个字母保持不变，但将第二个字母’d’替换为’t’，将第三个字母’t’替换为’d’。</p>
<script type="math/tex; mode=display">
\text{Decoder ['a', 't', 'd']: } ~~~ a \to a, ~~~ d \to t, ~~~ t \to d</script><p>所以atdt被解码为adtd。</p>
</li>
</ul>
<p>您可以以相同的方式阅读表格的其余部分。. </p>
<p>请注意，在每个已解码的消息中，在索引1和3处出现相同字母。这是用于解码atdt中的t的字母。替换代码的一个特征是每个<em>字母原件</em>都用相同的字母进行<em>置换</em>，因而<em>字母原件</em>出现在文本中的位置都会替换为相同的<em>替换字母</em>。解码器必须具有相同的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decoding</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Decoder</th> <th>atdt Decoded</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>['a' 'd' 't']</td> <td>['a' 't' 'd' 't']</td>
        </tr>
    </tbody>
        <tr>
            <td>['a' 't' 'd']</td> <td>['a' 'd' 't' 'd']</td>
        </tr>
    </tbody>
        <tr>
            <td>['d' 'a' 't']</td> <td>['d' 't' 'a' 't']</td>
        </tr>
    </tbody>
        <tr>
            <td>['d' 't' 'a']</td> <td>['d' 'a' 't' 'a']</td>
        </tr>
    </tbody>
        <tr>
            <td>['t' 'a' 'd']</td> <td>['t' 'd' 'a' 'd']</td>
        </tr>
    </tbody>
        <tr>
            <td>['t' 'd' 'a']</td> <td>['t' 'a' 'd' 'a']</td>
        </tr>
    </tbody>
</table>



<p>我们应该使用哪一个解码器？为了做出这个决定，我们必须了解英语中单词中，字母串转移的频率。我们的目标是根据解码结果中字母串的转移频率选择解码器。</p>
<p>我们用汇总了英语中，一些<em>双字母</em>或两个字母组合频率的数据。这是一个被称为<code>bigrams</code>的转移矩阵，用于对英语中双字母的可用信息进行粗略简化; 我们使用了Peter Norvig的双字母表，并将其限制在我们的三个字母的字母表中。对应于字母’a’的行假定以’a’开头的大约2％的双字母是’aa’，大约22％是’ad’，剩下的76％是’at’。</p>
<p>“aa”组合是罕见的，这是有道理的; 我们不经常使用像aardvark这样的词。甚至2％看起来很大，直到你记得它只是’aa’，’ad’和’at’中’aa’的比例，因为我们限制了字母表。如果你看它在所有 $26\times26$ 中的比例，会低得多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigrams</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>d</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.018099</td>
      <td>0.219458</td>
      <td>0.762443</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.570995</td>
      <td>0.159772</td>
      <td>0.269233</td>
    </tr>
    <tr>
      <th>t</th>
      <td>0.653477</td>
      <td>0.049867</td>
      <td>0.296656</td>
    </tr>
  </tbody>
</table>
</div>



<p>现在将真实文本视为具有此转移矩阵的马尔可夫链的路径。一个有趣的历史是，这就是马尔科夫第一次提出马尔科夫过程时所做的事情 - 他分析了亚历山大普希金的韵文小说，<em><a href="https://zh.wikipedia.org/wiki/%E5%8F%B6%E7%94%AB%E7%9B%96%E5%B0%BC%C2%B7%E5%A5%A5%E6%B6%85%E9%87%91">Eugene Onegin</a></em> 中元音和辅音之间的转移。</p>
<p>如果真实的文本是tada，那么我们可以将序列tada视为马尔可夫链的路径。其概率可以由$P(t)P(t, a)P(a, d)P(d, a)$计算。我们将根据这个概率给每个解码器一个分数。较高的分数对应于更好的解码器。</p>
<p>为了分配分数，我们假设所有三个字母都以相同的概率开始路径。对于字母表中的三个字母，这与事实并不相符（每个字母出现的概率并不相同，我们可以忽略这一因素）。这意味着每条路径的概率将以1/3的系数开始，我们所要做的就是对所有概率进行排名。我们将只计算$P(t, a)P(a, d)P(d, a)$，值约为 8%。</p>
<p>根据我们上面<code>decoding</code>的表格，tada是我们通过将解码器[‘t’，’d’，’a’]应用到我们的数据atdt得到的结果。现在，我们可以说<em>这个解码器在给定数据上的得分</em>是8％。稍后我们将介绍更正式的计算和术语。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># score of decoder [&#x27;t&#x27;, &#x27;d&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="number">0.653477</span> * <span class="number">0.219458</span> * <span class="number">0.570995</span></span><br></pre></td></tr></table></figure>
<pre><code>0.08188682431730866
</code></pre><p>为了自动化这种计算，我们可以使用<code>prob_of_path</code>方法。请记住，它的第一个参数是初始状态，第二个参数是由序列中剩余状态组成的列表或数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigrams.prob_of_path(<span class="string">&#x27;t&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br></pre></td></tr></table></figure>
<pre><code>0.081886816291942444
</code></pre><p>我们是否应该决定将我们的消息atdt解码为tada？如果我们认为8％的可能性很高，那么答案为是。但，如果其他的解码器具有更高的可能性呢？在那种情况下，当然选择得分高的。</p>
<p>因此，我们需要全部六个“解码器”路径中的概率。</p>
<p>让我们定义一个函数<code>score</code>，它将获取一个列表或一组字符，并使用<code>bigrams</code>转移矩阵返回相应路径的概率。在我们的示例中，这与返回相应解码器的分数相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> bigrams.prob_of_path(x[<span class="number">0</span>], x[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>以下是按分数降序排列的结果。有一个明显的赢家：对应于消息’data’的解码器[‘d’，’t’，’a’]的分数是任何其他解码器的两倍以上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decoding = decoding.with_column(<span class="string">&#x27;Score of Decoder&#x27;</span>, decoding.apply(score, <span class="number">1</span>))</span><br><span class="line">decoding.sort(<span class="string">&#x27;Score of Decoder&#x27;</span>, descending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Decoder</th> <th>atdt Decoded</th> <th>Score of Decoder</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>['d' 't' 'a']</td> <td>['d' 'a' 't' 'a']</td> <td>0.284492        </td>
        </tr>
    </tbody>
        <tr>
            <td>['d' 'a' 't']</td> <td>['d' 't' 'a' 't']</td> <td>0.134142        </td>
        </tr>
    </tbody>
        <tr>
            <td>['t' 'd' 'a']</td> <td>['t' 'a' 'd' 'a']</td> <td>0.0818868       </td>
        </tr>
    </tbody>
        <tr>
            <td>['a' 'd' 't']</td> <td>['a' 't' 'd' 't']</td> <td>0.0102363       </td>
        </tr>
    </tbody>
        <tr>
            <td>['t' 'a' 'd']</td> <td>['t' 'd' 'a' 'd']</td> <td>0.00624874      </td>
        </tr>
    </tbody>
        <tr>
            <td>['a' 't' 'd']</td> <td>['a' 'd' 't' 'd']</td> <td>0.00294638      </td>
        </tr>
    </tbody>
</table>



<h3 id="问题的规模"><a href="#问题的规模" class="headerlink" title="问题的规模"></a>问题的规模</h3><p>当字母表较大时，我们在三个字符的字母表上做的工作，将会变得非常可怕。52个小写字母和大写字母，以及空格字符和所有标点，形成一个大约70个字符的字母表。这给了我们70！不同的解码器需要考虑。理论上，我们必须找到这70！个中每一个的可能性和并将他们排序。</p>
<p>这是70！个解码器。我们的计算系统无法处理那么多，其他系统也会遇到同样的问题。</p>
<p>下面计算了70！的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.factorial(<span class="number">70</span>)</span><br></pre></td></tr></table></figure>
<pre><code>11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000
</code></pre><p>一个可能的解决方案是从这70！个可能的解码器中随机采样，然后只从采样的排序中进行挑选。但是我们如何从70！中进行采样？根据字母表，均匀随机采样并不是一个好主意，因为那不太可能让我们快速获得理想解决方案。</p>
<p>我们希望的采样程序，能够选择具有高概率的良好解码器。好的解码器生成的文本几乎比所有其他解码器生成的文本具有更高概率。换句话说，给定数据，良好的解码器比其他解码器具有更高的可能性。</p>
<p>您可以使用贝叶斯规则记下这种可能性。让 $S$代表所有可能排列的空间; 如果字母表有 $N$字符，然后$S$有$N!$个元素。对于任何随机挑选的排列$j$，给出数据的解码器的概率是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{Likelihood of } j \text{ given the encoded text}
&= \frac{\frac{1}{N!} P(\text{encoded text} \mid \text{decoder = }j)}
{ {\sum_{i \in S} } \frac{1}{N!} P(\text{encoded text} \mid \text{decoder = }i)} \\ \\
&=\frac{P(\text{encoded text} \mid \text{decoder = }j)}
{ {\sum_{i \in S} } P(\text{encoded text} \mid \text{decoder = }i)}
\end{align*}</script><p>对于给定的编码文本，分母是使所有似然性总和为1的归一化常数项。它出现在每个解码器的可能性中。在我们使用三个字母字母表的示例中，我们忽略了它，因为我们可以找出所有六个解码器的分子并且只是比较它们。分子就是我们称之为解码器的<em>分数</em>。</p>
<p>即使字母表很大，对于任何特定的解码器 $j$我们可以通过转移概率顺序相乘计算得到分子，就像我们在我们的例子中所做的那样。但是对于所有可能的解码器，我们无法对全量解码器执行此操作，因此我们无法列出所有可能的分数，我们无法对他们求和。因此，我们不知道可能性的分母，甚至找不到合适的近似值。</p>
<p>我们现在需要的是一种方法，即使我们不知道归一化常数，也可以从概率分布中得出一个近似解。这就是Markov Chain Monte Carlo帮助我们做的事情。</p>
<h2 id="马尔可夫链蒙特卡罗法"><a href="#马尔可夫链蒙特卡罗法" class="headerlink" title="马尔可夫链蒙特卡罗法"></a>马尔可夫链蒙特卡罗法</h2><p>马尔可夫链蒙特卡罗（MCMC）的目标是从复杂的高维分布中生成随机样本，这种情况下，我们的信息不完整。例如，我们可能不知道分布的归一化常量，正如我们在上一节的示例中看到的那样。</p>
<p>比如我们想根据分布$\pi$生成样本。我们就假设$\pi$是一个非常巨大有限集上的概率分布。MCMC依赖于较少的采样值。</p>
<ul>
<li><p>设$X_0, X_1, \ldots $是一个定义在有限空间上的不可约非周期性马尔科夫链。那么，当$n$变大时，$X_n$的分布趋向于稳态。如果我们可以创建一个稳态分布为$\pi$ 的马尔科夫链${X_n}$ ，那么我们使用对于一个较大值$n$的 $X_n$，来长期运行链条，从而模拟$\pi$（或其近似值）。</p>
</li>
<li><p>构建一个使得最终稳态分布为$\pi$的转移矩阵的最简单的方式是保证详细平衡方程有解。换言之，最简单的方法是尝试创建一个可逆链。</p>
</li>
<li><p>如果链是可逆的，那么详细平衡方程可以改写为：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\frac{\pi(j)}{\pi(i)} = \frac{P(i, j)}{P(j, i)}</script><p>右侧只涉及我们想要创建的链的转移概率。左侧仅涉及$\pi$中的项的比率。因此，即使我们不知道使$\pi$归一化的常数，也可以得到校验。</p>
<h3 id="Metropolis-算法"><a href="#Metropolis-算法" class="headerlink" title="Metropolis 算法"></a>Metropolis 算法</h3><p>究竟是谁第一个提出了相关算法来创建这样的马尔可夫链存在一定争议。黑斯廷斯提出了一般版本。在这里，我们将描述于1953年由Metropolis和共同作者提出的早期版本。</p>
<p>目标是创建一个转移矩阵 $\mathbb{P}$，使得$\pi$和$\mathbb{P}$能一起求解详细平衡方程。</p>
<p>该算法基于任意的对称转移矩阵$Q$，该矩阵会在状态空间上创建一个不可约的非周期性链。例如，如果状态空间是数值，你可以用“无论链条，它选择三个最接近的值（包括自身，每个的概率都是$1/3$）中的一个”开始链。对于一对状态$i$和$j$，转移概率$Q(i, j)$被称为<em>提议概率</em>。</p>
<p>以下是确定新链转移的步骤。</p>
<ul>
<li><p>假设连载时刻$n$时为状态$i$，即$X_n = i$。根据提议概率$Q(i, j)$选择一个状态$j$。这个$j$是链可能的目的状态。</p>
</li>
<li><p>定义<em>接受概率</em>如下</p>
<script type="math/tex; mode=display">
r(i, j) = \frac{\pi(j)}{\pi(i)}</script></li>
<li><p>如果 $r(i, j) \ge 1$, 则 $X_{n+1} = j$.</p>
</li>
<li><p>如果 $r(i, j) &lt; 1$, 通过抛硬币的方式，随机选择$r(i, j)$。 </p>
<ul>
<li>如果硬币正面向上，则 $X_{n+1} = j$. </li>
<li>如果硬币反面向上，则 $X_{n+1} = i$.</li>
</ul>
</li>
<li>以 $X_{n+1}$为起始值，重复所有步骤。</li>
</ul>
<p>因此，新链要么移动到$Q$，要么保持原样。我们说它基于$Q$和$r$<em>接受移动到新状态</em>，否则它不动。</p>
<p>因为提案链是不可约的，新的链条也是不可约的。因为它可以保持原位，所以它是非周期性的。因此它具有稳态分布。算法表示这种稳态分布与$\pi$相同，即我们定义的$r(i, j)$。</p>
<h3 id="算法的相关思考"><a href="#算法的相关思考" class="headerlink" title="算法的相关思考"></a>算法的相关思考</h3><p>在我们证明算法有效之前，让我们先来看看它在解码器环境中的作用。</p>
<p>首先注意$Q$是对称的，也是不可约的。对称性要求是有意义的，因为每个详细的平衡方程涉及转移$i \to j$和$j \to i$。</p>
<p>修正启动的解码器并将其命名为$i$。现在你必须决定链接下一步的位置，即下一个解码器是什么。由该程序启动的算法，在根据$Q$选择了一个$j$之后会关闭。我们称之为<em>$Q$ 建议移动到$j$</em>。</p>
<p>分布$\pi$包含所有解码器的可能性，决定链是否应移至$j$的根本因素是希望最终得到具有高可能性的解码器，因此需要比较$\pi(i)$和$\pi(j)$。</p>
<p>该算法通过比较<em>接受比率</em> $r(i, j) = \pi(j)/\pi(i)$ 和 1 之间的大小。</p>
<ul>
<li><p>如果$r(i, j) \ge 1$，那么$j$的概率至少和$i$一样大，所以你<em>接受提议</em>并且移动到$j$。 </p>
</li>
<li><p>如果$r(i, j) &lt; 1$,那么建议的解码器$j$的可能性比当前的$i$要<em>小</em>，所以暂时先保持在$i$。但这可能会使链条陷入局部最大值。该算法通过抛硬币（随机选择）提供了避免这种情况的机会。如果硬币为反面，即使$j$比当前具有<em>更低</em>的可能性，链条移动到$j$。我们的想法是，从这个新位置开始，可能存在解码器的路径，这些解码器具有最高的可能性。</p>
</li>
</ul>
<h3 id="算法实践"><a href="#算法实践" class="headerlink" title="算法实践"></a>算法实践</h3><p>我们现在将表明由Metropolis算法创建的链的详细平衡方程，是如何通过期望$\pi$和转移矩阵$\mathbb{P}$求解的。</p>
<p>选择任意两个状态$i$和$j$</p>
<h4 id="案例-1-pi-i-pi-j"><a href="#案例-1-pi-i-pi-j" class="headerlink" title="案例 1: $\pi(i) = \pi(j)$"></a>案例 1: $\pi(i) = \pi(j)$</h4><p>当$r(i, j) = 1$。通过算法和$Q$的对称性，有$P(i, j) = Q(i, j)$和$P(j, i) = Q(j, i) = Q(i, j)$。</p>
<p>因此，$P(i, j) = P(j, i)$，满足详细平衡方程$\pi(i)P(i, j) = \pi(j)P(j, i)$。</p>
<h4 id="案例-2-pi-j-lt-pi-i"><a href="#案例-2-pi-j-lt-pi-i" class="headerlink" title="案例 2: $\pi(j) &lt; \pi(i)$"></a>案例 2: $\pi(j) &lt; \pi(i)$</h4><p>当 $r(i, j) &lt; 1$，有</p>
<script type="math/tex; mode=display">
P(i, j) ~=~ Q(i, j)r(i, j) 
~=~ Q(j, i)\frac{\pi(j)}{\pi(i)} ~~~ \text{(symmetry of } Q \text{ and definition of }r)</script><p>此时 $r(j, i) &gt; 1$，则根据算法有 $P(j, i) = Q(j, i)$。</p>
<p>因此</p>
<script type="math/tex; mode=display">
P(i, j) ~ = ~ P(j, i)\frac{\pi(j)}{\pi(i)}</script><p>这与下面是一样的</p>
<script type="math/tex; mode=display">
\pi(i)P(i, j) ~ = ~ \pi(j)P(j, i)</script><h4 id="案例-3-pi-j-gt-pi-i"><a href="#案例-3-pi-j-gt-pi-i" class="headerlink" title="案例 3: $\pi(j) &gt; \pi(i)$"></a>案例 3: $\pi(j) &gt; \pi(i)$</h4><p>交换案例 2 中$i$和$j$的角色。 </p>
<p>以上就是！一个简单而出色的想法，为困难问题提供解决方案。在实验中，当您实现解码文本的算法时，您将看到它的实际效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/Markov/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/29/Markov/" class="post-title-link" itemprop="url">【翻译活动】面向数据科学的概率论-10.马尔科夫链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-29 17:54:22" itemprop="dateCreated datePublished" datetime="2018-07-29T17:54:22+08:00">2018-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-08-05 19:32:39" itemprop="dateModified" datetime="2018-08-05T19:32:39+08:00">2018-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<a href="https://nbviewer.jupyter.org/github/prob140/textbook/blob/gh-pages/notebooks/Chapter_10/">prob140/textbook/notebooks/ch_10</a></p>
<p>译者：<a href="https://github.com/Yao544303">喵十八</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/">谷歌翻译</a></p>
</blockquote>
<h1 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h1><p><em>条件概率分布</em>（Conditional Probability Distribution，或者<em>条件分布</em>，Conditional Distribution）是现代概率论中的概念：已知两个相关的随机变量X和Y，随机变量Y在条件{X=x}下的条件概率分布是指当已知X的取值为某个特定值x之时，Y的概率分布。 如果Y在条件{X=x}下的条件概率分布是连续分布，那么其密度函数称作Y在条件{X=x}下的条件概率密度函数（条件分布密度、条件密度函数）。与条件分布有关的概念，常常以“条件”作为前缀，如条件期望、条件方差等等。</p>
<p><em>转移</em> 与<em>转移概率</em>：从状态1变为状态2，称之为状态转移，其对应的概率称之为转移概率。</p>
<p><em>可数无穷</em>：是指集合中的元素可以与自然数一一对应,也就是说可以用自然数来”数”它的数量,从而其数量为可数无穷. </p>
<h1 id="本章所需python包"><a href="#本章所需python包" class="headerlink" title="本章所需python包"></a>本章所需python包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line"><span class="keyword">from</span> datascience <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> prob140 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">&#x27;fivethirtyeight&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> misc</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIDDEN</span></span><br><span class="line">s = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">refl_walk_probs</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="comment"># staying in the same state</span></span><br><span class="line">    <span class="keyword">if</span> i-j == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># moving left or right</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">2</span> &lt;= i &lt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(i-j) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.25</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># moving right from 1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># moving left from 5</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">reflecting_walk = MarkovChain.from_transition_function(s, refl_walk_probs)</span><br></pre></td></tr></table></figure>
<h1 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h1><p>一个 <em>随机过程</em> 是某一概率空间（这里的空间，理解为域更合适，是指一系列随机状态的合集。不是与时间相对的空间，后面的时间也类似）中一系列随机状态的集合。我们将研究一种在<em>离散时间</em>域内演化过程，即有如下随机状态 $X_0, X_1, X_2, \ldots $。想象一下，从时刻0的状态 $X_0$ 开始,不断执行对应时间的操作，状态随之转移。以此类推，在时刻$n$ 时，转移为状态 $n$。</p>
<p>我们已经见过这种过程的例子。例如伯努利实验中，一系列的抛硬币事件构成的独立同分布的序列，就形成这样的过程。每次事件在0和1两个值之间来回传递，每个值都独立于所有其他值。但在许多有趣的过程中，未来的事件的值依赖于当前事件的值，以及过去事件的值。我们可以使用过去和现在来预测未来。</p>
<p>马尔科夫链，是以<a href="https://en.wikipedia.org/wiki/Andrey_Markov">安德烈·马尔科夫</a>的名字命名的一类随机过程。一个非正式的描述如下，对于马尔科夫链而言，将来的状态的值只取决于当前状态的值，而与如何达到当前状态的值无关。这被称为<em>马尔科夫性质</em>。从形式上看</p>
<ul>
<li>对于任一$n \ge 1$， $X_{n+1}$ 的条件分布，只取决于 $X_0, X_1, \ldots , X_n$中的$X_n$</li>
<li>也就是说，对于每一个可能值的序列$i<em>0, i_1, \ldots, i_n, i</em>{n+1}$,</li>
</ul>
<script type="math/tex; mode=display">P(X_{n+1} = i_{n+1} \mid X_0 = i_0, X_1 = i_1 , \ldots, X_{n-1} = i_{n-1}, X_n = i_n) = P(X_{n+1} = i_{n+1} \mid X_n = i_n)</script><p>例如在一个随机漫步试验中，赌徒以a美元的财富开始，然后连续投掷一枚公平的硬币（正反面概率都为50%）。如果硬币为正面，他就获得1美元，如果是反面，他就输掉1美元。<br>设$X<em>{0} = a$，则$n &gt; 0$令$X</em>{n+1} = X_n + I_n$，其中$I_1, I_2, \ldots $是伯努利实验中的独立同分布序列。马尔科夫性质适用于整个过程：给出赌徒在时刻$n$的财富数，那他在时刻$n+1$时的财富数的取值只与其在时刻$n$时的财富数有关，与$n$之前无关。所以该过程$X_0, X_1, X_2, \ldots $是一个马尔科夫链，代表着赌徒的财富随时间的演变。</p>
<p>马尔可夫链的<em>状态空间</em>是链中状态可能值的集合。上述随机漫步的状态空间是所有整数的集合。在本课程中，我们将状态空间限制为离散且有限的。</p>
<h3 id="条件独立"><a href="#条件独立" class="headerlink" title="条件独立"></a>条件独立</h3><p>两个随机变量$X$和$Y$是相互独立是指，$X$处于条件$Y$的情况的条件分布和不处于$Y$的情况下的条件分布是一致的。<br>随机变量$X$和$Y$<em>相对于$Z$条件独立</em> 是指，$X$在条件$Y$和$Z$的情况下的条件分布和在条件$Z$的情况下的条件分布式一致。也就是说，$Z$这一关于$Y$的额外条件，不会影响$X$的值。</p>
<p>在马尔可夫链中，如果定义时刻$n$为现在，定义时刻$n+1$为未来，时刻序列$0$到$n-1$作为过去，马尔科夫性质意味着过去和未来是条件独立的。</p>
<h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>设$X_0, X_1, X_2, \ldots $为状态空间$S$中马尔科夫链。根据马尔科夫性质，有限长度的<em>路径</em>或<em>轨迹</em>的概率如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
& P(X_0 = i_0, X_1 = i_1, X_2 = i_2, \ldots, X_n = i_n) \\
& = ~ 
P(X_0 = i_0)P(X_1 = i_1 \mid X_0 = i_0)P(X_2 = i_2 \mid X_1 = i_1) \cdots
P(X_n = i_n \mid X_{n-1} = i_{n-1})
\end{align*}</script><p>上式中的条件概率，也被称为<em>转移概率</em>。对于状态$i$和$j$，条件概率$P(X_{n+1} = j \mid X_n = i)$被称为<em>时刻$n$时的一阶转移概率</em>。</p>
<p>对于许多链，例如随机漫步，这些一阶转移概率仅仅由状态$i$和$j$决定，而与时刻$n$无关。<br>示例：</p>
<script type="math/tex; mode=display">
\begin{equation}
P(X_{n+1} = j \mid X_n = i) = 
 \begin{cases} 
      \frac{1}{2} & \text{if } j = i-1 \text{ or } j = i+1 \\
      0 & \text{ otherwise}
   \end{cases}
\end{equation}</script><p>对所有的$n$都与时刻无关。 </p>
<h3 id="固定转移概率"><a href="#固定转移概率" class="headerlink" title="固定转移概率"></a>固定转移概率</h3><p>当一阶转移概率与时刻$n$无关时，称之为<em>固定</em>或者<em>时间同质</em>的。我们将在本课程中学习的所有马尔可夫链都具有时间同质的转移概率。<br>对于这样的链，定义<em>一阶转移概率</em>如下：  </p>
<script type="math/tex; mode=display">
P(i, j) ~ = ~ P(X_{n+1} = j \mid X_n = i) ~ = ~ P(X_1 = j \mid X_0 = i)</script><p>Then</p>
<script type="math/tex; mode=display">
P(X_0 = i_0, X_1 = i_1, X_2 = i_2, \ldots, X_n = i_n)
~ = ~ P(X_0 = i_0)P(i_0, i_1)P(i_1, i_2) \cdots P(i_{n-1}, i_n)</script><p>一阶转移概率可以表示为矩阵的元素。这不仅仅是为了符号的紧凑-它导致了一个强大的理论。</p>
<h3 id="一阶转移矩阵"><a href="#一阶转移矩阵" class="headerlink" title="一阶转移矩阵"></a>一阶转移矩阵</h3><p>链的<em>一阶转移矩阵</em>描述如下，矩阵$\mathbb{P}$，其中$(i, j)$位置处的元素是$P(i, j) = P(X_1 = j \mid X_0 = i)$。</p>
<p>通常，$\mathbb{P}$简称为<em>转移矩阵</em>。注意两个重要属性：</p>
<ul>
<li>$\mathbb{P}$是一个正方形矩阵: 它的行和列都由状态空间索引构成。</li>
<li>$\mathbb{P}$的每一行: 对任一状态$i$, 和时刻$n$, 行$i$ 包含了在$X<em>n = i$ 情况下，$X</em>{n+1}$的条件分布。 因为它的每一行的和都为1， $\mathbb{P}$ 也被称为 <em>随机矩阵</em>.</li>
</ul>
<p>让我们看一下示例中转移矩阵的样子。 </p>
<h3 id="粘性反转随机漫步"><a href="#粘性反转随机漫步" class="headerlink" title="粘性反转随机漫步"></a>粘性反转随机漫步</h3><p>通常，马尔可夫链的转移行为更容易在<em>转移图</em>而不是矩阵中描述。下面是状态1,2,3,4和5上的链的转移图。该图显示了一阶转移概率。</p>
<ul>
<li>如果链条处于任何状态，它移动到原有状态的概率为0.5。</li>
<li>如果链处于状态2到4，则它移动到其两个相邻状态中的一个的概率为0.25。</li>
<li>如果链处于状态1或5，则它移动到其相邻状态的概率为0.5。</li>
</ul>
<p><img src="/image/prob140/10-1-trans_refl.png" alt="Reflecting Lazy Walk"></p>
<p>我们称其为<em>反转</em>是在状态1和5可以反转掉头进行转移。整个漫步过程有<em>粘性</em>是指其可能移动到原有状态。</p>
<p>转移图非常适合理解链移动的规则。但是，对于计算，转移矩阵更有帮助。</p>
<p>要开始构造矩阵，我们将数组<code>s</code>设置为状态集，并为转移函数<code>refl_walk_probs</code> 设置成入参为$i$和$j$，返回值为$P(i, j)$的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">refl_walk_probs</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="comment"># staying in the same state</span></span><br><span class="line">    <span class="keyword">if</span> i-j == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># moving left or right</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">2</span> &lt;= i &lt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(i-j) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.25</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># moving right from 1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># moving left from 5</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>您可以使用<code>prob140</code>库来构造<code>MarkovChain</code>对象。<code>from_transition_function</code>方法有两个参数：</p>
<ul>
<li>状态构成的数组</li>
<li>转移函数</li>
</ul>
<p>并显示<code>MarkovChain</code>对象的一阶转移矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk = MarkovChain.from_transition_function(s, refl_walk_probs)</span><br><span class="line">reflecting_walk</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.50</td>
      <td>0.50</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.50</td>
      <td>0.50</td>
    </tr>
  </tbody>
</table>
</div>



<p>比较转移矩阵$\mathbb{P}$和转移图，并确认它们包含的有关转移概率的信息一致。</p>
<p>为了找到从状态$i$转移到$j$的概率，只需找矩阵$i$行$j$列的值即可。</p>
<p>如果您知道起始状态，则可以使用$\mathbb{P}$找到任何有限路径的概率。例如，假设从1开始，那么它具有路径[2,2,3,4,3]的概率是</p>
<script type="math/tex; mode=display">
P(1, 2)P(2, 2)P(2, 3)P(3, 4)P(4, 3) \approx 0.4\%</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.5</span> * <span class="number">0.5</span> * <span class="number">0.25</span> * <span class="number">0.25</span> * <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<pre><code>0.00390625
</code></pre><p><code>MarkovChain</code>对象的<code>prob_of_path</code>方法可以省去写乘法的麻烦。它将起始状态和路径的其余部分（在列表或数组中）作为其参数，并返回路径的概率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.prob_of_path(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<pre><code>0.00390625
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.prob_of_path(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<pre><code>0.0
</code></pre><p>您可以使用<code>simulate_path</code>方法模拟链的路径。它有两个参数：起始状态和路径的步数。默认情况下，它返回一个由路径中的状态序列组成的数组。可选参数<code>plot_path=True</code>绘制模拟路径。运行几次下面的单元格，看看输出如何变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.simulate_path(<span class="number">1</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 1, 2, 2, 2, 3, 2])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.simulate_path(<span class="number">1</span>, <span class="number">10</span>, plot_path=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/prob140/10-2-output.png" alt="png"></p>
<h3 id="n-阶转移矩阵"><a href="#n-阶转移矩阵" class="headerlink" title="$n$-阶转移矩阵"></a>$n$-阶转移矩阵</h3><p>对于状态$i$和$j$, 耗费$n$步，从状态$i$转移为状态$j$的可能性，称为从$i$到$j$的$n$-阶转移概率。 形式上定义为：</p>
<script type="math/tex; mode=display">
P_n(i, j) ~ = ~ P(X_n = j \mid X_0 = i)</script><p>在这种表示方法中，一阶转移概率$P(i, j)$也可以写作$P_1(i, j)$。</p>
<p>$n$-阶转移概率$P_n(i, j)$可以使用$n$-阶转移矩阵$(i, j)$位置处的元素表示。对于任意状态$i$，$n$-阶转移矩阵的第$i$行包含了从状态$i$开始的链的条件分布$X_n$</p>
<p> <code>MarkovChain</code>的<code>transition_matrix</code>方法，使用$n$作为入参，并返回一个$n$-阶转移矩阵。以下是本节前面定义的粘性反转随机漫步的两阶转移矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.transition_matrix(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.3750</td>
      <td>0.5000</td>
      <td>0.125</td>
      <td>0.0000</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.2500</td>
      <td>0.4375</td>
      <td>0.250</td>
      <td>0.0625</td>
      <td>0.0000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0625</td>
      <td>0.2500</td>
      <td>0.375</td>
      <td>0.2500</td>
      <td>0.0625</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.0000</td>
      <td>0.0625</td>
      <td>0.250</td>
      <td>0.4375</td>
      <td>0.2500</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>0.125</td>
      <td>0.5000</td>
      <td>0.3750</td>
    </tr>
  </tbody>
</table>
</div>



<p>你可以轻松地手动计算各个条目。例如，$(1, 1)$是分两步从状态1进入状态1的可能性。有两种方法可以实现这一目标：</p>
<ul>
<li>[1, 1, 1]</li>
<li>[1, 2, 1]</li>
</ul>
<p>假设1是起始状态，则两条路径的总概率为$(0.5 \times 0.5) + (0.5 \times 0.25) = 0.375$.</p>
<p>由于马尔科夫性质，基于一阶转移概率，就能得到二阶转移概率。</p>
<p>一般而言，我们可以通过调节链条在时刻1时的位置，来计算$P_2(i, j)$</p>
<script type="math/tex; mode=display">
\begin{align*}
P_2(i, j) ~ &= ~ P(X_2 = j \mid X_0 = i) \\
&= ~ \sum_k P(X_1 = k, X_2 = j \mid X_0 = i) \\
&= ~ \sum_k P(X_1 = k \mid X_0 = i)P(X_2 = j \mid X_1 = k) \\
&= ~ \sum_k P(i, k)P(k, j)
\end{align*}</script><p>如上结果为$\mathbb{P} \times \mathbb{P} = \mathbb{P}^2$矩阵的$(i, j)$位置处元素。因此，二阶转移矩阵为$\mathbb{P}^2$。</p>
<p>通过归纳证明，能总结出，$n$-阶转移矩阵为$\mathbb{P}^n$。</p>
<p>这是粘性反转随机漫步的5步转移矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.transition_matrix(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.246094</td>
      <td>0.410156</td>
      <td>0.234375</td>
      <td>0.089844</td>
      <td>0.019531</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.205078</td>
      <td>0.363281</td>
      <td>0.250000</td>
      <td>0.136719</td>
      <td>0.044922</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.117188</td>
      <td>0.250000</td>
      <td>0.265625</td>
      <td>0.250000</td>
      <td>0.117188</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.044922</td>
      <td>0.136719</td>
      <td>0.250000</td>
      <td>0.363281</td>
      <td>0.205078</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.019531</td>
      <td>0.089844</td>
      <td>0.234375</td>
      <td>0.410156</td>
      <td>0.246094</td>
    </tr>
  </tbody>
</table>
</div>



<p>这是一个表示方法，但要使用矩阵，我们必须以Python识别为矩阵的形式表示它。方法<code>get_transition_matrix</code>为我们做到了这一点。需要步数$n$作为入参，并以numpy矩阵的格式返回$n$-阶转移矩阵。</p>
<p>对于粘性反转随机漫步，我们将从提取$\mathbb{P}$开始P作为矩阵<code>refl_walk_P</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refl_walk_P = reflecting_walk.get_transition_matrix(<span class="number">1</span>)</span><br><span class="line">refl_walk_P</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.5 ,  0.5 ,  0.  ,  0.  ,  0.  ],
       [ 0.25,  0.5 ,  0.25,  0.  ,  0.  ],
       [ 0.  ,  0.25,  0.5 ,  0.25,  0.  ],
       [ 0.  ,  0.  ,  0.25,  0.5 ,  0.25],
       [ 0.  ,  0.  ,  0.  ,  0.5 ,  0.5 ]])
</code></pre><p>让我们检查前面显示的5-阶转移矩阵是否与$\mathbb{P}^5$相同。您可以使用<code>np.linalg.matrix_power</code>将计算矩阵的非负整数次幂。第一个参数是矩阵，第二个参数是幂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.matrix_power(refl_walk_P, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.24609375,  0.41015625,  0.234375  ,  0.08984375,  0.01953125],
       [ 0.20507812,  0.36328125,  0.25      ,  0.13671875,  0.04492188],
       [ 0.1171875 ,  0.25      ,  0.265625  ,  0.25      ,  0.1171875 ],
       [ 0.04492188,  0.13671875,  0.25      ,  0.36328125,  0.20507812],
       [ 0.01953125,  0.08984375,  0.234375  ,  0.41015625,  0.24609375]])
</code></pre><p>这确实与<code>transition_matrix</code>显示的矩阵相同，但难以阅读。</p>
<p>当我们想要在计算中使用$\mathbb{P}$，我们将使用此矩阵表示。对于显示和阅读，<code>transition_matrix</code> 则更好。</p>
<h3 id="长期运行"><a href="#长期运行" class="headerlink" title="长期运行"></a>长期运行</h3><p>要理解马尔科夫链的长跑行为，令$n$变大，并检查对于开始状态的每个$X_n$值。这些都包含在$n$-阶转移矩阵$\mathbb{P}^n$中。</p>
<p>如下展示了随机漫步中，$n = 25, 50$, 和 $100$情况下的$\mathbb{P}^n$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.transition_matrix(<span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.129772</td>
      <td>0.256749</td>
      <td>0.25</td>
      <td>0.243251</td>
      <td>0.120228</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.128374</td>
      <td>0.254772</td>
      <td>0.25</td>
      <td>0.245228</td>
      <td>0.121626</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.125000</td>
      <td>0.250000</td>
      <td>0.25</td>
      <td>0.250000</td>
      <td>0.125000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.121626</td>
      <td>0.245228</td>
      <td>0.25</td>
      <td>0.254772</td>
      <td>0.128374</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.120228</td>
      <td>0.243251</td>
      <td>0.25</td>
      <td>0.256749</td>
      <td>0.129772</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.transition_matrix(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.125091</td>
      <td>0.250129</td>
      <td>0.25</td>
      <td>0.249871</td>
      <td>0.124909</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.125064</td>
      <td>0.250091</td>
      <td>0.25</td>
      <td>0.249909</td>
      <td>0.124936</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.125000</td>
      <td>0.250000</td>
      <td>0.25</td>
      <td>0.250000</td>
      <td>0.125000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.124936</td>
      <td>0.249909</td>
      <td>0.25</td>
      <td>0.250091</td>
      <td>0.125064</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.124909</td>
      <td>0.249871</td>
      <td>0.25</td>
      <td>0.250129</td>
      <td>0.125091</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.transition_matrix(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.125</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.125</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.125</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.125</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.125</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.125</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.125</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.125</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.125</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.25</td>
      <td>0.125</td>
    </tr>
  </tbody>
</table>
</div>



<p>$\mathbb{P}^{100}$中每一行都一样！这意味着，对于随机漫步而言，在时刻100时的条件分布不依赖于其起始状态。<em>链忘了他的起始点</em></p>
<p>你可以增加$n$，并且会看到$n$-阶转移矩阵保持一致。说明链已经<em>达到稳定</em></p>
<p>稳定性是许多马尔可夫链的显着特性，也是本章的主题。</p>
<h2 id="析构链"><a href="#析构链" class="headerlink" title="析构链"></a>析构链</h2><p>设$S$为一个有限状态或者可数无穷状态组成的集合。任一由集合$S$来索引行、列的随机矩阵，都是状态空间$S$下的某一马尔科夫链的转移矩阵。马尔可夫链的转移行为与矩阵变化保持一致。设置术语以讨论其中一些行为很有帮助。</p>
<h3 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h3><p>如果链可以从状态$i$转移到状态$j$，称之为<em>$i$可达$j$</em>，记作$i \rightarrow j$。通常，你能通过检查链的转移图来判定$i$ 是否可达$j$。一个$i \rightarrow j$正式的定义为：</p>
<ul>
<li>存在一条转移路径，从$i$开始，到$j$结束。</li>
<li>等价的, 存在 $n &gt; 0$ 使得 $P_n(i, j) &gt; 0$。</li>
</ul>
<p>当$i \rightarrow j$ 并且 $j \rightarrow i$时，称<em>$i$连通$j$</em> 记作$i \leftrightarrow j$。</p>
<p>如果链的所有状态彼此连通，则该链被称为<em>不可约</em>。</p>
<p>上一节的粘性反转随机漫步是不可约的，因为链条可能从每个状态相互之间都是连通的。</p>
<h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>在离散时间工作存在缺陷。其中一点就是<em>周期性</em>。让我们从随机漫步的例子开始，其中每个步骤是基于公平硬币的投掷。假设从状态0开始。然后定义只能在如下时刻返回状态0：正面和反面出现的数量完全相等，因此投掷的数量必须是偶数。我们说状态0 <em>有周期2</em></p>
<p>当链从状态$i$开始，并且经过$d$的倍数次数后能回到状态$i$，则称状态$i$ 有<em>周期</em> $d$。$d$是所有能使 $P_n(i, i) &gt; 0$的 $n$ 的最大公约数。</p>
<p>在上述描述的随机漫步中，所有的状态有周期2。</p>
<p>周期会导致长期行为的描述出现问题。例如：当状态$i$有周期3,序列$P_n(i, i)$可能看起来像”0, 0, positive, 0, 0, positive, $\ldots$”，因此限制声明可能会变得复杂。</p>
<p>在本课程中，我们将研究链条的长期行为，其中所有状态都是<em>非周期性的</em>，即它们具有周期1.换句话说，链条上无环。</p>
<p>你如何检查所有状态是否具有周期性？如果链是不可约的，那所有状态必须具有相同的周期。这个的证据并不困难，但我们不会这样做。因为这意味着如果一个链是不可约的，你就要找出其中每一个状态的周期，然后保证所有他状态都必须有相同的周期。</p>
<p>有些状态是很容易识别为非周期性的。如果1-阶转移概率$P(i, i)$ 为正，那么状态$i$是非周期性的。因为链可以保持在状态$i$任意长时间，其返回的结果是不成环的。</p>
<h3 id="样例：析构链"><a href="#样例：析构链" class="headerlink" title="样例：析构链"></a>样例：析构链</h3><p>考虑具有转移矩阵的链</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>c</strong></th>
<th><strong>d</strong></th>
<th><strong>e</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>a</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>b</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>c</strong></td>
<td>0</td>
<td>1/3</td>
<td>1/3</td>
<td>1/3</td>
<td>0</td>
</tr>
<tr>
<td><strong>d</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1/3</td>
<td>2/3</td>
</tr>
<tr>
<td><strong>e</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>4/5</td>
<td>1/5</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>状态$a$和$b$相互连通，并且不和其他状态可达。因此称为<em>连通类</em>。小矩阵</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>a</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>b</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>本身就是一个转移矩阵。尽管描述的是一个无聊的链，在状态$a$ 和$b$之间循环。$a$和$b$都有周期2。</p>
<ul>
<li>状态$d$和$e$构成连通类，并且是非周期性的。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>d</strong></th>
<th><strong>e</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>d</strong></td>
<td>1/3</td>
<td>2/3</td>
</tr>
<tr>
<td><strong>e</strong></td>
<td>4/5</td>
<td>1/5</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>状态$c$与自己连通，一旦转移为状态$b$或$d$, 就无法再返回。</li>
</ul>
<p>在本课程中，我们将只使用<em>有限状态空间上的不可约的非周期马尔可夫链</em>。我们所说的大部分内容也适用于周期链，以及具有可数无限状态空间的链。</p>
<h2 id="长期运行行为"><a href="#长期运行行为" class="headerlink" title="长期运行行为"></a>长期运行行为</h2><p>每个具有有限状态空间的不可约和非周期性的马尔可夫链在状态转移一段时间后会表现出惊人的规律性。以下收敛定理的证明超出了本课程的范围，但您已经通过计算看到了结果。对于某些类别无限多个状态的马氏链，所有结果都更为正确。</p>
<h3 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h3><p>设$X_0, X_1, \ldots$ 是有限状态空间$S$上的不可约，非周期性的马尔科夫链。那么对于所有的状态$i$和$j$有</p>
<script type="math/tex; mode=display">
P_n(i, j) \to \pi(j) ~~~ \text{as } n \to \infty</script><p>换言之，对于$S$中任意的$i$和$j$，从$i$到$j$的$n$-阶转移概率会逼近一个极限，并且不依赖于$i$。<br>此外</p>
<ul>
<li><p>对所有的状态$j$都有$\pi(j) &gt; 0$ ，和</p>
</li>
<li><p>$\sum_{j \in S} \pi(j) = 1$</p>
</li>
</ul>
<p>也就是说，当$n \to \infty$， $n$-阶转移矩阵$\mathbb{P}^n$的中每一行的值都会等于同一个向量$\pi$，其中每一项都为正值。</p>
<h3 id="限制特性"><a href="#限制特性" class="headerlink" title="限制特性"></a>限制特性</h3><p><strong>(i)</strong> 向量$\pi$是<em>平衡方程</em> $\pi \mathbb{P} = \pi$的唯一解。</p>
<p><strong>(ii)</strong> 如果对某些$n$，$X_n$的分布为$\pi$，那么，对于$m &gt; n$，其分布 $X_m$ 也同样是$\pi$。因此，称$\pi$为链的<em>静态</em>或<em>稳态</em>分布。</p>
<p><strong>(iii)</strong> 对于每一个状态$j$, 向量$\pi$的第$j$th 元素$\pi(j)$是链的长期值在$j$的预期。</p>
<p>我们假设收敛定理是正确的; 然后其他相关的特性推断起来就相对容易了。在本节的其余部分，我们将建立这些特性并查看它们的使用方式。</p>
<h3 id="平衡方程"><a href="#平衡方程" class="headerlink" title="平衡方程"></a>平衡方程</h3><p>另$n \ge 0$，$i$和$j$是两个状态。然后</p>
<script type="math/tex; mode=display">
P_{n+1}(i, j) = \sum_{k \in S} P_n(i, k)P(k, j)</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{align*}
\lim_{n \to \infty} P_{n+1}(i, j) &= \lim_{n \to \infty} \sum_{k \in S} P_n(i, k)P(k, j) \\ \\
&= \sum_{k \in S} \big{(} \lim_{n \to \infty} P_n(i, k) \big{)} P(k, j)
\end{align*}</script><p>因为$S$是有限的，我们可以交换极限与和。现在将收敛定理应用于平稳性：</p>
<script type="math/tex; mode=display">
\pi(j) = \sum_{k \in S} \pi(k)P(k, j)</script><p>这被称为<em>平衡方程</em>。</p>
<p>在矩阵表示方法中，如果你把$\pi$当做行向量，方程可以写为</p>
<script type="math/tex; mode=display">
\pi = \pi \mathbb{P} ~~~~~ \text{或者，等价的} ~~~~~ \pi\mathbb{P} = \pi</script><p>这有助于计算$\pi$时没有限制。</p>
<p><strong>注意:</strong> 稳态不是状态空间$S$的元素。这是链条运行很长一段时间后的状况。让我们进一步研究这个问题。</p>
<h3 id="平衡态和稳态"><a href="#平衡态和稳态" class="headerlink" title="平衡态和稳态"></a>平衡态和稳态</h3><p>要想看看这些方程中的“平衡”是什么，就需要想象一下这个链的大量独立复制。例如，根据粘性反转随机漫步的转移概率，想象大量的粒子在状态1到5之间移动，并假设所有粒子在时刻1,2,3，……… 都彼此独立。</p>
<p>然后在任何时刻和任何状态$j$，有一些比例的粒子离开$j$，和另一些比例的粒子进入$j$。平衡方程表明这两个比例是相等的。</p>
<p>让我们通过再次查看方程来检查：对于任何状态$j$,</p>
<script type="math/tex; mode=display">
\pi(j) = \sum_{k \in S} \pi(k)P(k, j)</script><p>对于每一个$k \in S$ (包括 $k=j$)，以$\pi(k)$ 作为链运行很长一段时间后离开状态$k$的粒子的比例。等式左边是离开状态$j$的粒子的比例。等式右边求和的每一项都是离开状态$k$并转向状态$j$的粒子比例。求和之后，就是所有进入状态$j$的粒子。等式成立时，链是<em>平衡的</em>。</p>
<p>收敛于平稳性的定理表明，当$n$变大时，链趋于平衡。当链确实达到平衡时，对于$n$，其分布$X_n$为$\pi$，然后它保持平衡。原因：</p>
<script type="math/tex; mode=display">
P(X_{n+1} = j) = \sum_{i \in S} P(X_n = i)P(i, j) = \sum_{i \in S} \pi(i)P(i, j) = \pi(j)</script><p>通过平衡方程。现在使用归纳法。</p>
<p>特别是，如果链以其静止分布$\pi$开始，那么之后每一个$n$的分布$X_n$都是$\pi$。</p>
<h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>不难表明,如果平衡方程有解，那么它必须是$\pi$，$X_n$的边际分布的极限。我们不会做证明; 它基本上重复了我们用来推导平衡方程的步骤。你应该意识到，一个不可约的，非周期的，有限状态马尔可夫链只有一个稳态分布。</p>
<p>如果您碰巧猜测到平衡方程的解，这将特别有用。如果您猜到了一个概率分布解，那么您已经找到了链的稳态分布。</p>
<h3 id="长期运行时各个状态占比"><a href="#长期运行时各个状态占比" class="headerlink" title="长期运行时各个状态占比"></a>长期运行时各个状态占比</h3><p>有状态$j$ ，令$I_m(j)$代表事件${X_m = j}$。<em>链花费在状态$j$处转移次数比例</em>，当转移次数从1至$n$，表述如下：</p>
<script type="math/tex; mode=display">
\frac{1}{n} \sum_{m=1}^n I_m(j)</script><p>因此，当链从状态$i$开始，<em>链花费在状态$j$处转移次数比例预期</em>为</p>
<script type="math/tex; mode=display">
\frac{1}{n} \sum_{m=1}^n E(I_m(j) \mid X_0 = i) 
= \frac{1}{n} \sum_{m=1}^n P(X_m = j \mid X_0 = i) 
= \frac{1}{n} \sum_{m=1}^n P_m(i, j)</script><p>现在回想一下实数序列的收敛性质：当$n \to \infty$时，$x_n \to x$，那么序列的均值也会收敛于$x$</p>
<script type="math/tex; mode=display">
\frac{1}{n} \sum_{m=1}^n x_m \to x ~~~ \text{as } n \to \infty</script><p>令$x_n = P_n(i, j)$。通过收敛性可得</p>
<script type="math/tex; mode=display">
P_n(i, j) \to \pi(j) ~~~ \text{as } n \to \infty</script><p>因此平均值也会收敛:</p>
<script type="math/tex; mode=display">
\frac{1}{n} \sum_{m=1}^n P_m(i, j) \to \pi(j) ~~~ \text{as } n \to \infty</script><p>因此，长期过程的链花费在状态$j$处转移次数比例预期为$\pi(j)$，其中$\pi$链的固定分布。</p>
<h3 id="粘性反转漫步的稳态分布"><a href="#粘性反转漫步的稳态分布" class="headerlink" title="粘性反转漫步的稳态分布"></a>粘性反转漫步的稳态分布</h3><p>我们在前面的部分对此进行了研究。转移图是</p>
<p><img src="/image/prob140/10-1-trans_refl.png" alt="image.png"></p>
<p>这是转移矩阵$\mathbb{P}$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.50</td>
      <td>0.50</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.50</td>
      <td>0.50</td>
    </tr>
  </tbody>
</table>
</div>



<p> <code>MarkovChain</code>的方法<code>steady_state</code>返回一个稳态分布$\pi$。 之前看到过这是$\mathbb{P}$行的极限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflecting_walk.steady_state()</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Value</th> <th>Probability</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1    </td> <td>0.125      </td>
        </tr>
    </tbody>
        <tr>
            <td>2    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>3    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>4    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>5    </td> <td>0.125      </td>
        </tr>
    </tbody>
</table>



<p>我们也可是使用平衡方程求解$\pi$。当然，这看起来有些多余，因为Python已经给出了$\pi$。当转移矩阵很大，且是分数的情况，使用Python是不错的操作。</p>
<p>根据平衡方程：</p>
<script type="math/tex; mode=display">
\pi(1) = \sum_{k=1}^s \pi(k)P(k, 1)</script><p>也就是说，使用$\pi$乘以$\mathbb{P}$中的<code>1</code>列</p>
<script type="math/tex; mode=display">
\pi(1) = \pi(1)\cdot 0.5 ~ + ~ \pi(2) \cdot 0.25 = 0.5\pi(1) + 0.25\pi(2)</script><p>按照相同的过程获得所有五个平衡方程：</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(1) &= 0.5\pi(1) + 0.25\pi(2) \\
\pi(2) &= 0.5\pi(1) + 0.5\pi(2) + 0.25\pi(3) \\
\pi(3) &= 0.25\pi(2) + 0.5\pi(3) + 0.25\pi(4) \\
\pi(4) &= 0.25\pi(3) + 0.5\pi(4) + 0.5\pi(5) \\
\pi(5) &= 0.25\pi(4) + 0.5\pi(5)
\end{align*}</script><p>一些观察结果使系统易于解决。</p>
<ul>
<li>通过重新排列第一个等式，我们得到 $\pi(2) = 2\pi(1)$。</li>
<li>通过对称性, $\pi(1) = \pi(5)$ 和 $\pi(2) = \pi (4)$。</li>
<li>因为 $\pi(2) = \pi(4)$,  等式$\pi(3)$ 表明 $\pi(3) = \pi(2) = \pi(4)$。</li>
</ul>
<p>所以$\pi$的分布为</p>
<script type="math/tex; mode=display">
\big{(} \pi(1), 2\pi(1), 2\pi(1), 2\pi(1), \pi(1) \big{)}</script><p>因为$\pi$是一个条件分布概率，其和为1。即 $8\pi(1)$的值为1，可以得到</p>
<script type="math/tex; mode=display">
\pi = \big{(} \frac{1}{8}, \frac{2}{8}, \frac{2}{8}, \frac{2}{8}, \frac{1}{8} \big{)}</script><p>这和我们用<code>distribution</code>计算$n=100$的结果一致。事实上，我们可以使用该方法<code>steady_state</code>来获得$\pi$:</p>
<p>这意味着从长远来看，这一部分的随机漫步预计将花费大约12.5％的时间在状态1，25％的时间用于状态2,3和4，其余12.5%的时间在状态5。</p>
<h3 id="懒惰的随机循环漫步"><a href="#懒惰的随机循环漫步" class="headerlink" title="懒惰的随机循环漫步"></a>懒惰的随机循环漫步</h3><p>现在让状态空间在圆上排列五个点。假设该过程从点1开始，并且在每个步骤中保持在概率为0.5的位置（因此是粘性的），或者移动到两个相邻点中的一个，每个概率为0.25，而不管其他移动。</p>
<p>换言之，除了$1 \rightarrow 5$ 和 $5 \rightarrow 1$这个漫步的转移和上面的随机漫步是相同的。 可以在转移图中总结此转移行为，请注意，所有状态的转移行为都是相同的。</p>
<p><img src="/image/prob140/10-3-trans_circle.png" alt="Lazy Circle Walk"></p>
<p>在每一步中，下一步的动作都是通过从三个选项中随机选择和链的当前位置来确定的，而不是从它到达该位置的方式。所以这个过程就是马尔可夫链。我们称之为 $X_0, X_1, X_2, \ldots $ 并定义其转移矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_walk_probs</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> i-j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">abs</span>(i-j) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.25</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">abs</span>(i-j) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.25</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>   </span><br><span class="line">        </span><br><span class="line">circle_walk = MarkovChain.from_transition_function(s, circle_walk_probs)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk</span><br></pre></td></tr></table></figure>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.25</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
      <td>0.25</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.25</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.25</td>
      <td>0.50</td>
    </tr>
  </tbody>
</table>
</div>



<p>由于转移行为的对称性，任何状态出现的概率，都不应该大于任何其他状态，因此$\pi(j)$的值是相同的。这可以用<code>steady_state</code>验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle_walk.steady_state()</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Value</th> <th>Probability</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1    </td> <td>0.2        </td>
        </tr>
    </tbody>
        <tr>
            <td>2    </td> <td>0.2        </td>
        </tr>
    </tbody>
        <tr>
            <td>3    </td> <td>0.2        </td>
        </tr>
    </tbody>
        <tr>
            <td>4    </td> <td>0.2        </td>
        </tr>
    </tbody>
        <tr>
            <td>5    </td> <td>0.2        </td>
        </tr>
    </tbody>
</table>



<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>这里有两个例子来说明如何找到稳态分布以及如何使用它。</p>
<h3 id="Ehrenfest的扩散模型"><a href="#Ehrenfest的扩散模型" class="headerlink" title="Ehrenfest的扩散模型"></a>Ehrenfest的扩散模型</h3><p><a href="https://en.wikipedia.org/wiki/Paul_Ehrenfest">Paul Ehrenfest</a> 提出了许多气体粒子扩散模型，其中一个我们将在这里研究。</p>
<p>该模型说有两个容器总共含有$N$个粒子。在每个瞬间，随机选择容器，并且独立于容器随机选择颗粒。然后将所选粒子放入所选容器中; 如果它已经在那个容器中，那就留在那里。</p>
<p>令$X_n$表示时刻$n$时容器1中的粒子数。那么$X_0, X_1, \ldots$是一个马尔科夫链，其转移概率描述如下：</p>
<p>\begin{equation}<br>P(i, j) =<br> \begin{cases}<br>      \frac{N-i}{2N} &amp; \text{if } j = i+1 \<br>      \frac{1}{2} &amp; \text{if } j = i \<br>      \frac{i}{2N} &amp; \text{if } j = i-1 \<br>      0 &amp; \text{otherwise}<br>   \end{cases}<br>\end{equation}</p>
<p>这条链显然是不可约的。它是非周期性的，因为 $P(i, i) &gt; 0$.</p>
<p><strong>问题.</strong> 链的稳态分布是什么？ </p>
<p><strong>回答.</strong> 使用电脑， 所以，先找到$N=100$时的稳态分布，然后检查对于一般的$N$是否一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">states = np.arange(N+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transition_probs</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> j == i:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> j == i+<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (N-i)/(<span class="number">2</span>*N)</span><br><span class="line">    <span class="keyword">elif</span> j == i-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> i/(<span class="number">2</span>*N)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ehrenfest = MarkovChain.from_transition_function(states, transition_probs)</span><br><span class="line">Plot(ehrenfest.steady_state(), edges=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/image/prob140/10-4-output.png" alt="png"></p>
<p>这看起来很像二项式（100,1 / 2）分布。实际上它<em>就是</em>二项式（100,1 / 2）分布。既然你已经猜到了，你所要做的就是将它插入到平衡方程中并检查它们是否有效。</p>
<p>平衡方程是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(0) &= \frac{1}{2}\pi(0) + \frac{1}{2N}\pi(1) \\
\pi(j) &= \frac{N-(j-1)}{2N}\pi(j-1) + \frac{1}{2}\pi(j) + \frac{j+1}{2N}\pi(j+1), ~~~ 1 \le j \le N-1 \\
\pi(N) &= \frac{1}{2N}\pi(N-1) + \frac{1}{2}\pi(N)
\end{align*}</script><p>您已经通过查看$N=100$的结果猜测了答案。但是如果你想从头开始，你必须简化平衡方程并尝试用$\pi(0)$表示$\pi$的所有元素。你会得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
\pi(1) &= N\pi(0) \\ \\
\pi(2) &= \frac{N(N-1)}{2} \pi0 = \binom{N}{2} \pi(0)
\end{align*}</script><p>可以归纳推导如下：</p>
<script type="math/tex; mode=display">
\pi(j) = \binom{N}{j} \pi(0)</script><p>换句话说，稳态分布分布与二项式系数成比例。所以当 $\pi(0) = 1/2^N$可以使所有元素的和为1,分布为二项分布 $(N, 1/2)$。</p>
<h3 id="预期奖励"><a href="#预期奖励" class="headerlink" title="预期奖励"></a>预期奖励</h3><p>假设我长时间运行上一节中的懒惰反转随机漫步。如下，这是它的稳态分布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stationary = reflecting_walk.steady_state()</span><br><span class="line">stationary</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
    <thead>
        <tr>
            <th>Value</th> <th>Probability</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1    </td> <td>0.125      </td>
        </tr>
    </tbody>
        <tr>
            <td>2    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>3    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>4    </td> <td>0.25       </td>
        </tr>
    </tbody>
        <tr>
            <td>5    </td> <td>0.125      </td>
        </tr>
    </tbody>
</table>



<p><strong>问题 1.</strong> 假设每次链条处于状态4时, 我赢得$$4$; 每次进入状态5, 我赢得$$5$; 否则我赢不到钱. 我奖励的期望是多少？</p>
<p><strong>回答 1.</strong> 从长远来看，链条处于稳定状态。所以，有62.5%的概率，我赢不到钱，有25%的概率我赢$$4$，12.5%的概率，我赢$$5$。综上，计算可得奖励的期望为$$1.625$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>*<span class="number">0.625</span> + <span class="number">4</span>*<span class="number">0.25</span> + <span class="number">5</span>*<span class="number">.125</span></span><br></pre></td></tr></table></figure>
<pre><code>1.625
</code></pre><p><strong>问题 2.</strong> 假设每次链条处于状态$i$, 我抛$i$枚硬币，并记录正面次数。从长期来看，我每次得到正面个数的期望是多少？</p>
<p><strong>回答 2.</strong> 每次链条处于状态$i$,期望得到$i/2$个正面。 当链处于稳态, 投掷硬币的期望数是3。所以，从长期来看，正面个数的期望是1.5。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stationary.ev()/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>1.5
</code></pre><p>这看上去是人为的，请考虑一下：假设我在上面玩游戏，并且在每一个动作中我告诉你我得到的头数，<em>但我不告诉你链在哪个状态</em>。我<em>隐藏</em>了潜在的马尔可夫链。如果您尝试重新创建马尔可夫链所采用的步骤序列，那么您正在使用隐马尔可夫模型。它们广泛用于模式识别，生物信息学和其他领域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/sklearn-PMML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/11/sklearn-PMML/" class="post-title-link" itemprop="url">Python sklearn中训练的模型导出为PMML</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-11 22:34:52 / Modified: 22:36:01" itemprop="dateCreated datePublished" datetime="2018-07-11T22:34:52+08:00">2018-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>自2007年发布以来，scikit-learn已经成为Python重要的机器学习库了。scikit-learn简称sklearn，支持包括分类、回归、降维和聚类四大机器学习算法。还包含了特征提取、数据处理和模型评估三大模块。<br>sklearn拥有着完善的文档，上手容易，具有着丰富的API，在学术界颇受欢迎。sklearn已经封装了大量的机器学习算法，包括LIBSVM和LIBINEAR。同时sklearn内置了大量数据集，节省了获取和整理数据集的时间。<br>本文介绍了如何将sklearn中的模型导出为PMML文件，方便后续的工程上线操作，内容包括涉及环境的搭建和中间遇到的坑。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>Python 基本操作，会使用pip 或者Anaconda进行依赖库管理</li>
<li>Maven 基本操作</li>
<li>Java 命令基本操作</li>
</ul>
<h1 id="sklearn2pmml-相关组件安装"><a href="#sklearn2pmml-相关组件安装" class="headerlink" title="sklearn2pmml 相关组件安装"></a>sklearn2pmml 相关组件安装</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>Python 2.7，3.4 或者更新。</li>
<li>scikit-learn 0.16.0 或者更新。</li>
<li>sklearn-pandas 0.0.10 或者更新。</li>
<li>sklearn2pmml 0.14.0 或者更新。</li>
</ul>
<h2 id="安装scikit-learn"><a href="#安装scikit-learn" class="headerlink" title="安装scikit-learn"></a>安装scikit-learn</h2><p>使用pip 安装，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U scikit-learn</span><br></pre></td></tr></table></figure></p>
<p>使用conda 安装，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install scikit-learn</span><br></pre></td></tr></table></figure><br>个人强烈建议，使用<a href="https://anaconda.org/">Anaconda</a> 进行Python 版本管理，使用conda命令进行安装。（貌似因为源的问题，conda中被墙的可能性小）</p>
<p>详细内容，可以参见 <a href="http://scikit-learn.org/stable/install.html">sklearn 安装文档</a></p>
<h2 id="安装skkearn-pandas"><a href="#安装skkearn-pandas" class="headerlink" title="安装skkearn-pandas"></a>安装skkearn-pandas</h2><p>命令如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sklearn-pandas</span><br></pre></td></tr></table></figure><br>这个地方，如果因为被墙，可以去官网下载<a href="https://pypi.org/project/sklearn-pandas/#files">whl文件</a>到本地，假设路径为”/data/users/miao18/sklearn_pandas-1.6.0-py2.py3-none-any.whl”然后<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install /data/users/miao18/sklearn_pandas-1.6.0-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure><br>通过本地文件的方式安装。</p>
<h2 id="安装sklearn2pmml"><a href="#安装sklearn2pmml" class="headerlink" title="安装sklearn2pmml"></a>安装sklearn2pmml</h2><p>命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user --upgrade git+https://github.com/jpmml/sklearn2pmml.git</span><br></pre></td></tr></table></figure></p>
<h2 id="校验是否安装成功"><a href="#校验是否安装成功" class="headerlink" title="校验是否安装成功"></a>校验是否安装成功</h2><p>进入Python 命令行，输入如下命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sklearn, sklearn.externals.joblib, sklearn_pandas, sklearn2pmml</span><br><span class="line"></span><br><span class="line">print(sklearn.__version__)</span><br><span class="line">print(sklearn.externals.joblib.__version__)</span><br><span class="line">print(sklearn_pandas.__version__)</span><br><span class="line">print(sklearn2pmml.__version__)</span><br></pre></td></tr></table></figure><br>我的环境输出结果如下，符合要求：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.19.1</span><br><span class="line">0.11</span><br><span class="line">1.6.0</span><br><span class="line">0.26.0</span><br></pre></td></tr></table></figure></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sklearn2pmml import PMMLPipeline</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn import tree</span><br><span class="line">iris = load_iris()</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">pipeline = PMMLPipeline([(&quot;classifier&quot;, clf)])</span><br><span class="line">pipeline.fit(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"># 导出为PMML</span><br><span class="line">from sklearn2pmml import sklearn2pmml</span><br><span class="line">sklearn2pmml(pipeline, &quot;DecisionTreeIris.pmml&quot;, with_repr = True)</span><br></pre></td></tr></table></figure>
<p>工作目录下的DecisionTreeIris.pmml 就是导出的pmml文件。</p>
<p>这里需要注意，sklearn中都是以pipeline 的形式进行转化的。原型如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn2pmml(pipeline, pmml, user_classpath, with_repr, debug)</span><br></pre></td></tr></table></figure></p>
<h1 id="jpmml-sklearn"><a href="#jpmml-sklearn" class="headerlink" title="jpmml-sklearn"></a>jpmml-sklearn</h1><h2 id="软件版本-1"><a href="#软件版本-1" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>Python 2.7，3.4 或者更新。</li>
<li>scikit-learn 0.16.0 或者更新。</li>
<li>sklearn-pandas 0.0.10 或者更新。</li>
<li>sklearn2pmml 0.14.0 或者更新。</li>
<li>Java 1.8 或者更新。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从github 下载源码，并安装：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:jpmml/jpmml-sklearn.git</span><br><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><br>执行完毕后，在target目录下有 一个 converter-executable-1.4-SNAPSHOT.jar 的jar文件。</p>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><p>一个典型的workflow如下：</p>
<ol>
<li>使用Python 训练一个模型。</li>
<li>将模型序列化为pickle，并存到本地。</li>
<li>使用Java命令，将pickle文件转为pmml。</li>
</ol>
<h2 id="Python-侧生成一个pickle-文件"><a href="#Python-侧生成一个pickle-文件" class="headerlink" title="Python 侧生成一个pickle 文件"></a>Python 侧生成一个pickle 文件</h2><p>训练部分，和直接导出pmml类似，只是最后的落地文件，不直接导出为pmml，而是存成pickle文件，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from sklearn2pmml import PMMLPipeline</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn import tree</span><br><span class="line">iris = load_iris()</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">pipeline = PMMLPipeline([(&quot;classifier&quot;, clf)])</span><br><span class="line">pipeline.fit(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line">from sklearn.externals import joblib</span><br><span class="line">joblib.dump(pipeline, &quot;pipeline.pkl.z&quot;, compress = 9)</span><br></pre></td></tr></table></figure></p>
<h2 id="Java侧转换"><a href="#Java侧转换" class="headerlink" title="Java侧转换"></a>Java侧转换</h2><p>使用上文编译好的Jar包，进行转换，命令如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/jpmml-sklearn-executable-1.5-SNAPSHOT.jar --pkl-input pipeline.pkl.z --pmml-output pipeline.pmml</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分别使用了sklearn2pmml 和 jpmml-sklearn 进行导出pmml文件，操作过程类似。<br>使用sklearn2pmml 的方式更为便捷，直接在python 中就可以导出，这意味着每次训练完模型，就能快速生成一个pmml文件。<br>使用jpmml-sklearn，则可以对现有的pickle 文件进行操作。<br>两者各有优劣，请使用者根据实际情况按需使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/R-PMML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/11/R-PMML/" class="post-title-link" itemprop="url">R训练的模型导出为PMML</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-11 22:30:20 / Modified: 22:33:40" itemprop="dateCreated datePublished" datetime="2018-07-11T22:30:20+08:00">2018-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。<br>许多数据工程师或者数据分析师都习惯使用R进行数据挖掘和建模分析。<br>本文介绍了如何将R中的模型导出为PMML文件，方便后续的工程上线操作，内容包括涉及环境的搭建和中间遇到的坑。<br>本文介绍的三种方式，各自支持的机器学习模型种类不完全一致，文中附有官方文档链接，模型支持程度请查阅官方文档。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>R 基本操作</li>
<li>Maven 基本操作</li>
<li>Java 命令基本操作</li>
</ul>
<h1 id="R2PMML"><a href="#R2PMML" class="headerlink" title="R2PMML"></a>R2PMML</h1><p>这是一个R的包，用于将R中训练好的模型导出为PMML。<a href="https://github.com/jpmml/r2pmml">github链接</a></p>
<h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>Java 1.7 或者更新</li>
<li>R 3.5.0</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用devtools 从github的分支安装。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;devtools&quot;)</span><br><span class="line">library(&quot;devtools&quot;)</span><br><span class="line">install_git(&quot;git://github.com/jpmml/r2pmml.git&quot;)</span><br></pre></td></tr></table></figure></p>
<p><strong>注</strong><br>因为某些不可描述的原因，可能出现网站访问的问题，请灵活使用科学上网手段。<br>博主自己测试的时候，耗时在3min 左右。</p>
<h2 id="基本用法（只有模型部分）"><a href="#基本用法（只有模型部分）" class="headerlink" title="基本用法（只有模型部分）"></a>基本用法（只有模型部分）</h2><p>载入该包，然后调用保存模型即可，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;randomForest&quot;)</span><br><span class="line">library(&quot;r2pmml&quot;)</span><br><span class="line"></span><br><span class="line">data(iris)</span><br><span class="line"></span><br><span class="line"># 训练模型</span><br><span class="line">iris.rf = randomForest(Species ~ ., data = iris, ntree = 7)</span><br><span class="line">print(iris.rf)</span><br><span class="line"></span><br><span class="line"># 导出为 PMML</span><br><span class="line">r2pmml(iris.rf, &quot;iris_rf.pmml&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="添加预处理过程"><a href="#添加预处理过程" class="headerlink" title="添加预处理过程"></a>添加预处理过程</h2><p>数据在进入模型前，可以先进行预处理，一线简单的预处理操作也可以定义在PMML中，R代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;caret&quot;)</span><br><span class="line">library(&quot;randomForest&quot;)</span><br><span class="line">library(&quot;r2pmml&quot;)</span><br><span class="line"></span><br><span class="line">data(iris)</span><br><span class="line"></span><br><span class="line"># 创建预处理过程，0-1 标准化</span><br><span class="line">iris.preProcess = preProcess(iris, method = c(&quot;range&quot;))</span><br><span class="line"></span><br><span class="line"># 对原始数据进行预处理</span><br><span class="line">iris.transformed = predict(iris.preProcess, newdata = iris)</span><br><span class="line"></span><br><span class="line"># 使用预处理之后的数据训练模型</span><br><span class="line">iris.rf = randomForest(Species ~., data = iris.transformed, ntree = 7)</span><br><span class="line">print(iris.rf)</span><br><span class="line"></span><br><span class="line"># 导出PMML 文件</span><br><span class="line">r2pmml(iris.rf, &quot;iris_rf.pmml&quot;, preProcess = iris.preProcess)</span><br></pre></td></tr></table></figure></p>
<h1 id="PMML包"><a href="#PMML包" class="headerlink" title="PMML包"></a>PMML包</h1><p>R 中也支持了自带的PMML包,在最近的一次更新(2018.07.06)中，增加了支持模型的数量。</p>
<h2 id="软件版本-1"><a href="#软件版本-1" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>R 3.5.0</li>
</ul>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>需要用到的包有：XML PMML 需要提前安装，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install.packages(“XML”) </span><br><span class="line">install.packages(&#x27;pmml&#x27;)</span><br></pre></td></tr></table></figure><br>选择镜像之后，等几分钟就行了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>训练模型，和上面一致<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;randomForest&quot;)</span><br><span class="line">data(iris)</span><br><span class="line">iris.rf = randomForest(Species ~ ., data = iris, ntree = 7)</span><br><span class="line">print(iris.rf)</span><br></pre></td></tr></table></figure></p>
<p>将模型转为pmml之后，导出为pmml格式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;pmml&quot;)</span><br><span class="line">iris.rf.pmml &lt;- pmml(iris.rf,name=&quot;Iris Random Forest&quot;,data=iris.rf)</span><br><span class="line">savePMML(iris.rf.pmml,&quot;iris.rf.pmml&quot;,version=4.3)</span><br></pre></td></tr></table></figure></p>
<h1 id="JPMML-R"><a href="#JPMML-R" class="headerlink" title="JPMML-R"></a>JPMML-R</h1><p>上面两种方式，都是在R中，直接将模型导出为PMML。还可以将R的模型存为rds文件之后，调用Java 的方式安装。</p>
<h2 id="软件版本-2"><a href="#软件版本-2" class="headerlink" title="软件版本"></a>软件版本</h2><ul>
<li>Java 1.8 或者更新</li>
<li>R 3.5.0</li>
</ul>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>在github 下载相关源码之后，编译<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:jpmml/jpmml-r.git</span><br><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><br>在 target 目录下会生成converter-executable-1.3-SNAPSHOT.jar 文件。</p>
<h2 id="R中生成rds文件"><a href="#R中生成rds文件" class="headerlink" title="R中生成rds文件"></a>R中生成rds文件</h2><p>将训练好的模型保存为rds，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;randomForest&quot;)</span><br><span class="line">rf = randomForest(Species ~ ., data = iris)</span><br><span class="line">saveRDS(rf, &quot;rf.rds&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="将rds文件转为pmml文件"><a href="#将rds文件转为pmml文件" class="headerlink" title="将rds文件转为pmml文件"></a>将rds文件转为pmml文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/converter-executable-1.3-SNAPSHOT.jar --rds-input rf.rds --pmml-output rf.pmml</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了三种不同的方式，将R中训练好的模型导出为pmml文件。3种方式支持的模型不完全一致，比如 R2PMML 不支持glmnet，需要存glmnet的模型时，可以使用另外的方式。</p>
<h1 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h1><p><a href="https://github.com/jpmml/r2pmml">R2PMML</a><br><a href="https://cran.r-project.org/web/packages/pmml/">pmml: Generate PMML for Various Models</a><br><a href="https://github.com/jpmml/jpmml-r">JPMML-R</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/pmml-GeneralStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/08/pmml-GeneralStructure/" class="post-title-link" itemprop="url">PMML文档翻译 基本结构（GeneralStructure）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-08 18:42:42 / Modified: 18:43:45" itemprop="dateCreated datePublished" datetime="2018-07-08T18:42:42+08:00">2018-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>基于PMML Version4.3</li>
<li>基本可以视为官方文档的一个翻译</li>
<li>如有疏漏，请联系yao544303963@gmail.com</li>
</ul>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>PMML使用XML来表示数据挖掘模型。模型的结构用一个XML Schema来描述。一个PMML文档中可以包含多个数据挖掘模型。一个PMML文档本质就是一个XML文档，其根元素是一个PMML类型的元素。其基本结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;PMML version=&quot;4.3&quot;</span><br><span class="line">  xmlns=&quot;http://www.dmg.org/PMML-4_3&quot; </span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Header copyright=&quot;Example.com&quot;/&gt;</span><br><span class="line">  &lt;DataDictionary&gt; ... &lt;/DataDictionary&gt;</span><br><span class="line"></span><br><span class="line">  ... a model ...</span><br><span class="line"></span><br><span class="line">&lt;/PMML&gt;</span><br></pre></td></tr></table></figure></p>
<p>命名空间定义如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:schema</span><br><span class="line">  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">  targetNamespace=&quot;http://www.dmg.org/PMML-4_3&quot;</span><br><span class="line">  xmlns=&quot;http://www.dmg.org/PMML-4_3&quot;</span><br><span class="line">  elementFormDefault=&quot;unqualified&quot;&gt;</span><br></pre></td></tr></table></figure><br>这里需要注意，因为命名空间在当前形式中声明，所以PMML中不能使用不同的命名空间。<br>关于命名空间，详见<a href="http://www.w3school.com.cn/xml/xml_namespaces.asp">XML 命名空间</a></p>
<p>尽管一个PMML文件必须严格符合PMML XSD的定义，然而并不需要额外的解析器。为了确保是一个有效的XML文档，PMML 需要遵循一些额外的规则。更多的内容参见<a href="http://dmg.org/pmml/v4-3/Conformance.html">conformance rules </a></p>
<p>PMML文档的根元素，必须是PMML 类型的。如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;PMML&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Header&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;MiningBuildTask&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;DataDictionary&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;TransformationDictionary&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;</span><br><span class="line">        &lt;xs:group ref=&quot;MODEL-ELEMENT&quot;/&gt;</span><br><span class="line">      &lt;/xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;version&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:group name=&quot;MODEL-ELEMENT&quot;&gt;</span><br><span class="line">  &lt;xs:choice&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;AssociationModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;BayesianNetworkModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;BaselineModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;ClusteringModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;GaussianProcessModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;GeneralRegressionModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;MiningModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;NaiveBayesModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;NearestNeighborModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;NeuralNetwork&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;RegressionModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;RuleSetModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;SequenceModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;Scorecard&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;SupportVectorMachineModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;TextModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;TimeSeriesModel&quot;/&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;TreeModel&quot;/&gt;</span><br><span class="line">  &lt;/xs:choice&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中，模型部分由如下定义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;</span><br><span class="line">    &lt;xs:group ref=&quot;MODEL-ELEMENT&quot;/&gt;</span><br><span class="line">&lt;/xs:sequence&gt;</span><br></pre></td></tr></table></figure><br>可以看出，一个PMML文档可以包含不止一个模型。如果应用系统提供了模型的命名，并且PMML的消费者指定了该模型的命名。否则会使用第一个模型。<br>minOccurs=”0”,这个参数表示，模型列表可以为空。模型为空时，表示该PMML用来传输原始数据。不包含模型的PMML对于PMML消费者而言，意义不大。  </p>
<p>对于PMML4.3，属性<strong>version</strong>的值，必须为4.3。</p>
<p>元素MiningBuildTask 包含生成该模型时及训练阶段的配置参数的描述。该信息不是必要的，但许多情况下，对于模型的维护和理解很有帮助。MiningBuildTask中特有的结构，不是由PMML定义的。示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;MiningBuildTask&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure></p>
<p>通常来讲，PMML中的字段名是独一无二的。避免字段名重复是一个好习惯，可以使消费者使用起来更为简便，减少异常的发生。</p>
<p>某一类型的PMML模型都有其特定的用途，例如神经网络或者逻辑回归。有的用于回归，有的用于分类。因此PMML定义了5种不同类型的MINING-FUNCTION，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;MINING-FUNCTION&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;associationRules&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;sequences&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;classification&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;regression&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;clustering&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;timeSeries&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;mixed&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>分别为关联规则，序列，分类，聚类，回归。时间序列和混合，是上述5种的组合。</p>
<p>所有的PMML模型的顶层元素，都类似如下结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;ExampleModel&quot;&gt;</span><br><span class="line">   &lt;xs:complexType&gt;</span><br><span class="line">     &lt;xs:sequence&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;MiningSchema&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;Output&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;ModelStats&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;Targets&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;LocalTransformations&quot; minOccurs=&quot;0&quot; /&gt;</span><br><span class="line">       ...</span><br><span class="line">       &lt;xs:element ref=&quot;ModelVerification&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">       &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">     &lt;/xs:sequence&gt;</span><br><span class="line">     &lt;xs:attribute name=&quot;modelName&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">     &lt;xs:attribute name=&quot;functionName&quot; type=&quot;MINING-FUNCTION&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">     &lt;xs:attribute name=&quot;algorithmName&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">   &lt;/xs:complexType&gt;</span><br><span class="line"> &lt;/xs:element&gt;</span><br></pre></td></tr></table></figure><br>MiningSchema 是一个由模型使用到的字段组成的非空列表。<br>Output 模型的计算结果，比如预测概率或置信度等。<br>ModelStats 是字段的一个统计属性。<br>Targets 包含了目标值，以及相关的信息，如 0 1分类中，属于各个分类的概率。<br>LocalTransformations 包含了在本地转换操作用到的追加字段。<br>…(其他一些元素的定义)<br>ModelVerification 给出了样例数据以及模型结果样例，便于消费者验证有效性。</p>
<p><strong>属性</strong><br><strong>modelName</strong> 属性代表模型名字，用来确保该模型在PMML文件中的唯一性。该字段不是必要的。消费者可以根据需要，自由的管理模型名</p>
<p><strong>functionName</strong> 和 <strong>algorithmName</strong> 描述了数据挖掘模型的类型，例如是聚类模型还是分类模型。<strong>algorithmName</strong> 是自由类型的且只用于说明，可以包含任何用于描述该该算法和模型的内容。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>尽管非常罕见，分类模型可能出现多个解的情况。在这些情况下，PMML没有定义特殊的处理流程，只是按照DataFiled 中对类别的排序，推荐先出现的类别。</p>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>PMML的命名规范如下：</p>
<ul>
<li>元素名，首字母大写</li>
<li>属性名，首字母小写</li>
<li>常量，首字母小写</li>
<li>简单类型，全部大写</li>
</ul>
<p>为避免和减号产生歧义，’-‘不建议使用。</p>
<h1 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h1><p>在PMML Schema中可以通过Extension元素扩展模型内容。Extension元素必须出现在第一个子元素，或者组中第一的位置。这为了保证该元素中接下来的内容都受Extension元素的影响。每一个主要的元素都必须包含Extension元素作为第一个和最后一个子元素，来确保其最大的扩展性。</p>
<p>Extension Schema如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;Extension&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:complexContent mixed=&quot;true&quot;&gt;</span><br><span class="line">      &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;</span><br><span class="line">        &lt;xs:sequence&gt;</span><br><span class="line">          &lt;xs:any processContents=&quot;skip&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">        &lt;/xs:sequence&gt; </span><br><span class="line">        &lt;xs:attribute name=&quot;extender&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">        &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">        &lt;xs:attribute name=&quot;value&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">      &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:complexContent&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure></p>
<p>这些扩展的元素都含有一个ANY类型的模型来指向扩展的模型。不过这些元素的类型名必须以X开头，来避免和PMML后续增加的内容产生冲突。<br>相应的，Extension元素也有<strong>name</strong> 和 <strong>value</strong> 属性来指定字段名和值。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>扩展属性format可以通过如下方式在DataField内追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataField name=&quot;foo&quot; dataType=&quot;double&quot; optype=&quot;continuous&quot;&gt;</span><br><span class="line">  &lt;Extension name=&quot;format&quot; value=&quot;%9.2f&quot;/&gt;</span><br><span class="line">&lt;/DataField&gt;</span><br></pre></td></tr></table></figure></p>
<p>扩展元素 DataFieldSource 可以通过如下方式追加到DataField中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataField name=&quot;foo&quot; dataType=&quot;double&quot; optype=&quot;continuous&quot;&gt;</span><br><span class="line">  &lt;Extension&gt;</span><br><span class="line">    &lt;DataFieldSource sourceKnown=&quot;yes&quot;&gt;</span><br><span class="line">      &lt;Source&gt;derivedFromInput&lt;/Source&gt;</span><br><span class="line">    &lt;/DataFieldSource&gt;</span><br><span class="line">  &lt;/Extension&gt;</span><br><span class="line">&lt;/DataField&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="基础数据类型和对象"><a href="#基础数据类型和对象" class="headerlink" title="基础数据类型和对象"></a>基础数据类型和对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;NUMBER&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:double&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure>
<p>该定义常用来区别数值和其他类型的值。数值通常会包含符号，小数点，指数。XML Schema中float类型支持INF，-INF 和 NaN的表示。这些在NUMBER中是不支持的。除了NUMBER还有一些定义更严格的类型，类似于NUMBER的子类型。</p>
<p><strong>INT-NUMBER</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;INT-NUMBER&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:integer&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>必须是整数，不能是小数或指数。</p>
<p><strong>REAL-NUMBER</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;REAL-NUMBER&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:double&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>实数型，可以覆盖C/C++中 float、long或者double类型。科学计数法，如 1，23e4 也是支持的。INF,-INF，NaN 是不支持的。</p>
<p><strong>PROB-NUMBER</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;PROB-NUMBER&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:double&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>概率型，值在[0.0,1.0]之间，通常用来表示预测概率。</p>
<p><strong>PERCENTAGE-NUMBER</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;PERCENTAGE-NUMBER&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:double&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>百分比型，[0.0,100.0]之间的一个实数。</p>
<p>注意到这些对象并不强制XML解析器来检查他们的数据类型。但在PMML文档中定义了其有效性校验的相关操作。<br>许多元素都有输入字段的引用。PMML不使用<a href="https://blog.csdn.net/sweatlove/article/details/1681648">IDERF</a>来表示字段名，就是因为XML 标识的有效性校验不是必须的。而通过如下定义:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:simpleType name=&quot;FIELD-NAME&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure><br>则可以进行相关引用的校验。</p>
<h1 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h1><p>模型中通常包含一大堆数值组成的集合。Array 的定义和C or Java中的数组类似，Schema如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:complexType name=&quot;ArrayType&quot; mixed=&quot;true&quot;&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;n&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;type&quot; use=&quot;required&quot;&gt;</span><br><span class="line">    &lt;xs:simpleType&gt;</span><br><span class="line">      &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">        &lt;xs:enumeration value=&quot;int&quot;/&gt;</span><br><span class="line">        &lt;xs:enumeration value=&quot;real&quot;/&gt;</span><br><span class="line">        &lt;xs:enumeration value=&quot;string&quot;/&gt;</span><br><span class="line">      &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:simpleType&gt;</span><br><span class="line">  &lt;/xs:attribute&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;Array&quot; type=&quot;ArrayType&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Array 的内容是一组以空格分割的值，多个空格和单个空格效果一致。<br><strong>n</strong>：该属性定义了该序列的值数量。如果<strong>n</strong>的值给出了，那和值的数量必须保持一致，否则该pmml文档视为无效。<br><strong>type</strong>：该属性是必须的，指定类型便于后续解析。<br>特殊的，在String中存在空格 和 “ ,需要使用转义符，例子如下：<br><strong>例子</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Array n=&quot;3&quot; type=&quot;int&quot;&gt;1 22 3&lt;/Array&gt;</span><br><span class="line">&lt;Array n=&quot;3&quot; type=&quot;string&quot;&gt;ab  &quot;a b&quot;   &quot;with \&quot;quotes\&quot; &quot;&lt;/Array&gt;</span><br></pre></td></tr></table></figure></p>
<p>类似上面NUMBER有很多子类型，Array 也有，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:group name=&quot;NUM-ARRAY&quot;&gt;</span><br><span class="line">  &lt;xs:choice&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;Array&quot;/&gt;</span><br><span class="line">  &lt;/xs:choice&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:group name=&quot;INT-ARRAY&quot;&gt;</span><br><span class="line">  &lt;xs:choice&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;Array&quot;/&gt;</span><br><span class="line">  &lt;/xs:choice&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:group name=&quot;REAL-ARRAY&quot;&gt;</span><br><span class="line">  &lt;xs:choice&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;Array&quot;/&gt;</span><br><span class="line">  &lt;/xs:choice&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:group name=&quot;STRING-ARRAY&quot;&gt;</span><br><span class="line">  &lt;xs:choice&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;Array&quot;/&gt;</span><br><span class="line">  &lt;/xs:choice&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><p>只记录非0值的数组，类似系数矩阵<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;INT-SparseArray&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Indices&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;INT-Entries&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;n&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;defaultValue&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot; default=&quot;0&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;REAL-SparseArray&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Indices&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;REAL-Entries&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;n&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;defaultValue&quot; type=&quot;REAL-NUMBER&quot; use=&quot;optional&quot; default=&quot;0&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;Indices&quot;&gt;</span><br><span class="line">  &lt;xs:simpleType&gt;</span><br><span class="line">    &lt;xs:list itemType=&quot;xs:int&quot;/&gt;</span><br><span class="line">  &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;INT-Entries&quot;&gt;</span><br><span class="line">  &lt;xs:simpleType&gt;</span><br><span class="line">    &lt;xs:list itemType=&quot;xs:int&quot;/&gt;</span><br><span class="line">  &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;REAL-Entries&quot;&gt;</span><br><span class="line">  &lt;xs:simpleType&gt;</span><br><span class="line">    &lt;xs:list itemType=&quot;xs:double&quot;/&gt;</span><br><span class="line">  &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>n</strong> 该属性指定了稀疏数组的长度，这在没有指定数组最后一个对象的情况下，会非常有用。<br><strong>defaultValue</strong> 该属性指定了整个数组中，没有指定值情况下的默认值。<br>稀疏数组其实是由两个数组组成，索引数组Indices和值数组INT-Entries 或者 REAL-Entries。<br>索引数组从1开始，包含了值不为默认值的索引。<br>值数组是索引数组对应编号位的值。因此索引数组和值数组的长度必须保持一致。<br>形成稀疏数组的结构  如 1:3 2:6 8:9的索引数组为[1,2,8] 值数组为[3,6,9]。<br>综上，索引数组和值数组是成对出现的，否则PMML会视为无效。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>数组 0 3 0 0 42 0 0 可以用如下形式表示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;INT-SparseArray n=&quot;7&quot;&gt;</span><br><span class="line">  &lt;Indices&gt;2 5&lt;/Indices&gt;</span><br><span class="line">  &lt;INT-Entries&gt;3 42&lt;/INT-Entries&gt;</span><br><span class="line">&lt;/INT-SparseArray&gt;</span><br></pre></td></tr></table></figure></p>
<p>数组 0 0 0 0 0 0 0 可以用如下形式表示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;INT-SparseArray n=&quot;7&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>为了节省空间，一个矩阵会以对角矩阵或者稀疏矩阵的形式存储。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;Matrix&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:choice minOccurs=&quot;0&quot;&gt;</span><br><span class="line">      &lt;xs:group ref=&quot;NUM-ARRAY&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;MatCell&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:choice&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;kind&quot; use=&quot;optional&quot; default=&quot;any&quot;&gt;</span><br><span class="line">      &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;diagonal&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;symmetric&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;any&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">      &lt;/xs:simpleType&gt;</span><br><span class="line">    &lt;/xs:attribute&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;nbRows&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;nbCols&quot; type=&quot;INT-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;diagDefault&quot; type=&quot;REAL-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;offDiagDefault&quot; type=&quot;REAL-NUMBER&quot; use=&quot;optional&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;MatCell&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:simpleContent&gt;</span><br><span class="line">      &lt;xs:extension base=&quot;xs:string&quot;&gt;</span><br><span class="line">        &lt;xs:attribute name=&quot;row&quot; type=&quot;INT-NUMBER&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">        &lt;xs:attribute name=&quot;col&quot; type=&quot;INT-NUMBER&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">      &lt;/xs:extension&gt;</span><br><span class="line">    &lt;/xs:simpleContent&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure></p>
<p>矩阵通常用一个数组的序列（二维数组）或者矩阵元素的序列来表示。如果用数组表示，每个数组表示矩阵的一行。<br><strong>MatCells</strong> 矩阵元素通过行、列索引来指定对应位置的值。行、列索引从1开始。<br><strong>diagDefault</strong> 和 <strong>offDiagDefault</strong> 属性在使用稀疏矩阵时，必须设定。<br><strong>nbRows</strong> 和 <strong>nbCols</strong> 属性指定了矩阵的维度。如果其中一个属性没有指定，那便有矩阵表示（数组或者矩阵元素）的定义隐式定义。如使用了矩阵元素，那么矩阵的维度就是能容纳该元素得的维度值。</p>
<p><strong>kind</strong> 属性触发了矩阵的实际表示：</p>
<ul>
<li>diagonal: 只有一个数组，用来表示矩阵对角线元素</li>
<li>symmetric: 对称矩阵，用二维数组表示，第一个数组表示坐标(0,0)处元素, 第二个数组表示坐标(1，0)和(1，1)处元素，以此类推。描述整个左下半三角区。右上半三角区由对称求得。</li>
<li>any: 通过二维数组或者矩阵元素指定矩阵。</li>
</ul>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><p>矩阵<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  0  0 42  0</span><br><span class="line">0  1  0  0  0</span><br><span class="line">5  0  0  0  0</span><br><span class="line">0  0  0  0  7</span><br><span class="line">0  0  9  0  0</span><br></pre></td></tr></table></figure><br>可以用如下定义来表述：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Matrix nbRows=&quot;5&quot; nbCols=&quot;5&quot;&gt;</span><br><span class="line">  &lt;Array type=&quot;real&quot;&gt;0 0 0 42 0&lt;/Array&gt;</span><br><span class="line">  &lt;Array type=&quot;real&quot;&gt;0 1 0 0 0&lt;/Array&gt;</span><br><span class="line">  &lt;Array type=&quot;real&quot;&gt;5 0 0 0 0&lt;/Array&gt;</span><br><span class="line">  &lt;Array type=&quot;real&quot;&gt;0 0 0 0 7&lt;/Array&gt;</span><br><span class="line">  &lt;Array type=&quot;real&quot;&gt;0 0 9 0 0&lt;/Array&gt;</span><br><span class="line">&lt;/Matrix&gt;</span><br><span class="line">&lt;Matrix diagDefault=&quot;0&quot; offDiagDefault=&quot;0&quot;&gt;</span><br><span class="line">  &lt;MatCell row=&quot;1&quot; col=&quot;4&quot;&gt;42&lt;/MatCell&gt;</span><br><span class="line">  &lt;MatCell row=&quot;2&quot; col=&quot;2&quot;&gt;1&lt;/MatCell&gt;</span><br><span class="line">  &lt;MatCell row=&quot;3&quot; col=&quot;1&quot;&gt;5&lt;/MatCell&gt;</span><br><span class="line">  &lt;MatCell row=&quot;4&quot; col=&quot;5&quot;&gt;7&lt;/MatCell&gt;</span><br><span class="line">  &lt;MatCell row=&quot;5&quot; col=&quot;3&quot;&gt;9&lt;/MatCell&gt;</span><br><span class="line">&lt;/Matrix&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="无评分模型"><a href="#无评分模型" class="headerlink" title="无评分模型"></a>无评分模型</h1><p>找寻一个有效模型的道路通常是曲折和充满荆棘的。生成可部署的模型的尝试中出现失败是很正常的。在早期的试验阶段，会进行非常多的测试来寻找有用的特征。或者，从基础的角度说，训练模型使用的数据有问题的话，最后也无法生成正确的模型。相对，许多数据挖掘工具都会自动排除那些不符合要求的特征，或者制定一个最低限度的标准来确保模型可以被部署。</p>
<p>PMML包含许多帮助使用者了解模型质量的特征性，比如Statics 和 Model Explanation。这些描述性的元素对于验证模型的有效性，以及理解模型运行失败的原因很有包住。</p>
<p>反过来看，PMML既能产生好的结果，也能产生坏的结果，尤其是在整个系统中，PMML只是承担了接口人的角色，联接了模型生成者和模型消费者。这也就要求模型的消费者能够辨别PMML中是否包含一个有效的模型，或者PMML不能用于判断得分。<br>举个例子，如回归模型中，所有的独立变量都不能满足最小的重要性验证。在追加的描述信息中，应该有所体现，并且说明为何这些变量会被排除。或者，如果模型不能满足某些验证，模型的生成者需要将这些说明增加在Model Explanation中。<br>综上，存在这样一些模型，最后的产生的结果都是一样的，无法用于评分。模型消费者可以选择不去部署这些模型，或者部署他们只为加深理解，而不用于评分。</p>
<h1 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h1><p><a href="http://dmg.org/pmml/v4-3/GeneralStructure.html">PMML 4.3 - General Structure</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/pmml-DataDictionary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/08/pmml-DataDictionary/" class="post-title-link" itemprop="url">PMML文档翻译 数据字典（DataDictionary）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-08 18:41:12 / Modified: 18:42:02" itemprop="dateCreated datePublished" datetime="2018-07-08T18:41:12+08:00">2018-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>基于PMML Version4.3</li>
<li>基本可以视为官方文档的一个翻译</li>
<li>如有疏漏，请联系yao544303963@gmail.com</li>
</ul>
<h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>数据字典包含了数据挖掘模型中使用的字段定义。指定了字段类型和字段值的取值范围。<br>这些定义是独立的，无关于使用了何种数据集训练了何种模型。<br>一个数据字典，可以被多个模型、统计值以及其他相关的操作共享。</p>
<h1 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;DataDictionary&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;DataField&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Taxonomy&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;numberOfFields&quot; type=&quot;xs:nonNegativeInteger&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;DataField&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;xs:sequence&gt;</span><br><span class="line">        &lt;xs:element ref=&quot;Interval&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">        &lt;xs:element ref=&quot;Value&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;name&quot; type=&quot;FIELD-NAME&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;displayName&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;optype&quot; type=&quot;OPTYPE&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;dataType&quot; type=&quot;DATATYPE&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;taxonomy&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;isCyclic&quot; default=&quot;0&quot;&gt;</span><br><span class="line">      &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;0&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">      &lt;/xs:simpleType&gt;</span><br><span class="line">    &lt;/xs:attribute&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType name=&quot;OPTYPE&quot;&gt;      </span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;categorical&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;ordinal&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;continuous&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:simpleType name=&quot;DATATYPE&quot;&gt;      </span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;string&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;integer&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;float&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;double&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;boolean&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;date&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;time&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateTime&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateDaysSince[0]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateDaysSince[1960]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateDaysSince[1970]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateDaysSince[1980]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;timeSeconds&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateTimeSecondsSince[0]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateTimeSecondsSince[1960]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateTimeSecondsSince[1970]&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;dateTimeSecondsSince[1980]&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure>
<h1 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h1><h2 id="DataDictionary"><a href="#DataDictionary" class="headerlink" title="DataDictionary"></a>DataDictionary</h2><p>该元素定义了数据字典的顶层。可以包含三种类型的子元素： Extension、DataField、Taxonomy  </p>
<p><strong>包含属性：</strong></p>
<p><strong>numberOfFields</strong><br>该属性值是数据字典中定义的字段的数量，可以用来进行前后一致性的校验（字段数量的校验）</p>
<h2 id="DataField"><a href="#DataField" class="headerlink" title="DataField"></a>DataField</h2><p>该元素定义了字段。<br>在整个数据字典中，字段名称必须唯一。也有一些特殊情况，在整个PMML文档中，名称以必须唯一。</p>
<p><strong>包含属性：</strong><br><strong>displayName</strong>：<br>应用程序使用该名称来关联该字段。在XML文档内部，只有<strong>name</strong>的值是必须的，如果没有给出<strong>displayName</strong>，那其默认值就是<strong>name</strong>的值。<br>举个例子：<br>某个字段的<strong>name=”SCTAGE” displayName=”Customer age”</strong>。应用程序在调用PMML 消费者时，会在接口处使用Customer age来请求输入数据。一旦消费者接受了参数，并且和miningFields匹配上了，那么<strong>displayName</strong>就没有什么实际意义了，在内部处理中，都是使用<strong>name</strong>。</p>
<p><strong>optype</strong>：<br>字段的类型，即定义在这些字段值上的操作类型，主要有三类。</p>
<ul>
<li>categorical 类别型 只能进行相等或不相等的运算。（即，是这个分类，或者不是这个分类）</li>
<li>ordinal 定序型 有内在排序，可以比较，但是不适合加减运算。如年级编号。</li>
<li>continuous 连续型  数值</li>
</ul>
<p><strong>dataType</strong>：<br>字段值的类型（这个更类似于Java 或 C中的数据类型），比如类别型，就是所有的string<br>可选值如下：</p>
<ul>
<li>string</li>
<li>integer</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
<li>date</li>
<li>time</li>
<li>dateTime</li>
<li>dateDaysSince[0]</li>
<li>dateDaysSince[1960]</li>
<li>dateDaysSince[1970]</li>
<li>dateDaysSince[1980]</li>
<li>timeSeconds</li>
<li>dateTimeSecondsSince[0]</li>
<li>dateTimeSecondsSince[1960]</li>
<li>dateTimeSecondsSince[1970]</li>
<li>dateTimeSecondsSince[1980]</li>
</ul>
<p>类型的定义，详见<a href="https://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes</a><br>其中有三个类型是PMML 相较于 XML Schema 新增的，分别是timeSeconds,dateDaysSince[a Year],dateTimesSecondsSince[a Year],其中a Year 可以是0、1960、1970、1980中的一个值。注意到，a Year不是一个任意值，必须在允许的值中进行选取。如果可变的a Year 是必须的，那就需要考虑使用<a href="http://dmg.org/pmml/v4-3/BuiltinFunctions.html#datedayssinceyear">內建函数</a><br>PMML支持这些额外的类型，原因在于在数据挖掘中，经常需要将时间转化为可以比较和计算的数值。例如 2003-04-01 就可以通过 dateDaysSince[1960] 转为15796。</p>
<p><strong>taxonomy</strong>：<br>可选属性 <strong>taxonomy</strong> 关联了一个<a href="https://en.wikipedia.org/wiki/Taxonomy">taxonomy</a> 值。用来描述一个分层的值的情况。<br><em>Tips</em>：<br>这个值体现了一个继承性和分层性。</p>
<p><strong>isCyclic</strong>:<br>表示定序型的值是否可循环，如周日至周六</p>
<h1 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h1><p>DataFiled 定义了一组规则来验证值的有效性。<br>数据挖掘模型区分了如下三种值的情况：  </p>
<ul>
<li>Missing Data： 缺失值。  </li>
<li>Invalid Value： 无效值，即输入不为空，但是取值范围超出了给该值的取值区间。</li>
<li>Valid Value： 有效值，即不为以上两种情况的值。</li>
</ul>
<h1 id="值和区间"><a href="#值和区间" class="headerlink" title="值和区间"></a>值和区间</h1><p>Value 和 Interval 元素用来描述数据字典中值的情况和取值区间。</p>
<h2 id="Value-Schema"><a href="#Value-Schema" class="headerlink" title="Value Schema"></a>Value Schema</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;Value&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;value&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;displayValue&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;property&quot; default=&quot;valid&quot;&gt;</span><br><span class="line">      &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;valid&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;invalid&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;missing&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">      &lt;/xs:simpleType&gt;</span><br><span class="line">    &lt;/xs:attribute&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Interval-Schema"><a href="#Interval-Schema" class="headerlink" title="Interval Schema"></a>Interval Schema</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;Interval&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;closure&quot; use=&quot;required&quot;&gt;</span><br><span class="line">      &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;openClosed&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;openOpen&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;closedOpen&quot;/&gt;</span><br><span class="line">          &lt;xs:enumeration value=&quot;closedClosed&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">      &lt;/xs:simpleType&gt;</span><br><span class="line">    &lt;/xs:attribute&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;leftMargin&quot; type=&quot;NUMBER&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;rightMargin&quot; type=&quot;NUMBER&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连续型demo"><a href="#连续型demo" class="headerlink" title="连续型demo"></a>连续型demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataField name=&quot;SomeVariable&quot; dataType=&quot;double&quot; optype=&quot;continuous&quot;&gt;</span><br><span class="line">  &lt;Interval closure=&quot;closedClosed&quot; leftMargin=&quot;0&quot; rightMargin=&quot;100&quot;/&gt;</span><br><span class="line">  &lt;Value property=&quot;missing&quot; value=&quot;-999&quot;/&gt;</span><br><span class="line">&lt;/DataField&gt;</span><br></pre></td></tr></table></figure>
<p>表示取值区间[0, 100]，若为空，则取-999<br>Interval 只支持连续型（continuous)</p>
<h2 id="类别型demo"><a href="#类别型demo" class="headerlink" title="类别型demo"></a>类别型demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataField name=&quot;_target&quot; optype=&quot;categorical&quot; dataType=&quot;string&quot;&gt;</span><br><span class="line">	&lt;Value value=&quot;0&quot;/&gt;</span><br><span class="line">	&lt;Value value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/DataField&gt;</span><br></pre></td></tr></table></figure>
<p>不存在二分类的数据类型，所以二分类的定义如上。</p>
<h2 id="定序型demo"><a href="#定序型demo" class="headerlink" title="定序型demo"></a>定序型demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataField name=&quot;Volume&quot; optype=&quot;ordinal&quot; dataType=&quot;string&quot;&gt;</span><br><span class="line">  &lt;Value value=&quot;loud&quot;/&gt;</span><br><span class="line">  &lt;Value value=&quot;louder&quot;/&gt;</span><br><span class="line">  &lt;Value value=&quot;insane&quot;/&gt;</span><br><span class="line">&lt;/DataField&gt;</span><br></pre></td></tr></table></figure>
<p>如上，定序为出现顺序的逆序，及loud &lt; louder &lt; insane<br>加上 cyclic 参数，即可形成循环，如周日至周六</p>
<h1 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h1><p><a href="http://dmg.org/pmml/v4-3/DataDictionary.html">PMML 4.3 - Data Dictionary</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/pmml-Header/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/08/pmml-Header/" class="post-title-link" itemprop="url">PMML文档翻译-文件头（Header）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-08 18:39:41 / Modified: 18:40:49" itemprop="dateCreated datePublished" datetime="2018-07-08T18:39:41+08:00">2018-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>基于PMML Version4.3</li>
<li>基本可以视为官方文档的一个翻译</li>
<li>如有疏漏，请联系yao544303963@gmail.com</li>
</ul>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>包含了PMML文档的基本信息，例如模型的版权信息，模型的描述，以及生成该文件所用软件的信息（比如软件的名字和版本）。头文件中也会包含该PMML文件的生成时间。</p>
<h1 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;Header&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">      &lt;xs:element minOccurs=&quot;0&quot; ref=&quot;Application&quot;/&gt;</span><br><span class="line">      &lt;xs:element minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; ref=&quot;Annotation&quot;/&gt;</span><br><span class="line">      &lt;xs:element minOccurs=&quot;0&quot; ref=&quot;Timestamp&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;copyright&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;modelVersion&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;Application&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;version&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;Annotation&quot;&gt;</span><br><span class="line">  &lt;xs:complexType mixed=&quot;true&quot;&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;Timestamp&quot;&gt;</span><br><span class="line">  &lt;xs:complexType mixed=&quot;true&quot;&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element ref=&quot;Extension&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<h1 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>顶层标签，标记着header部分的开始。</p>
<p><strong>包含属性：</strong><br><strong>copyright</strong>：<br>包含了该模型的版权信息。应用生成的PMML文件应该允许用户可以指定或替换该属性值。自PMML 4.1 版本起，该属性是可选的。<br><strong>description</strong>：<br>这个属性包含了对模型的非特定描述。它需要包含程序在后续使用该模型时必要的信息，但不包括那些可以在application、annotation和data dictionary中可以精确描述的信息。这个属性只包含人类可读的信息。<br><strong>modelVersion</strong>：<br>这个属性描述了模型的版本信息。相同或相似的模型可能被多次生成，所以这个模型对于区分这些非常重要。  </p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>这个元素用来描述生成该模型的软件或应用。尽管生成的PMML模型是轻量级的，但是不同的机制会使基于同一个数据集产生的模型出现差异。  </p>
<p><strong>包含属性：</strong><br><strong>name</strong>：<br>生成该PMML文件的程序名称<br><strong>version</strong>：<br>生成该模型使用的应用的版本  </p>
<h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><p>该元素记录文件修改历史。每条注释都是一个自由的文本。用户可以在这里记录他们自己的标记。</p>
<h2 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h2><p>该元素记录模型文件的创建时间</p>
<h1 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h1><p><a href="http://dmg.org/pmml/v4-3/Header.html">PMML 4.3 - Header</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/pmml-catelog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/08/pmml-catelog/" class="post-title-link" itemprop="url">PMML 翻译计划目录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-08 18:36:28 / Modified: 18:39:06" itemprop="dateCreated datePublished" datetime="2018-07-08T18:36:28+08:00">2018-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PMML/" itemprop="url" rel="index"><span itemprop="name">PMML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>本系列基于<a href="">PMML 4.3</a> 版本</li>
<li>基本是原文的一个翻译，有些部分会加入一些个人的理解和相关知识点的说明</li>
<li>在模型部分，计划根据PMML文件结构，增加对模型结构的解释和介绍</li>
<li>本人技术水平有限，难免有所疏漏，如有问题，请联系yao544303963@gmail.com</li>
<li>所有版权归原组织(DMG)所有，版权说明详见 <a href="http://dmg.org/documents/dmg-pmml-license-2016.pdf">PMML Notice and License</a></li>
<li>坑开了，不知道什么时候填完，说不定还没填完，这个技术就过时了，欢迎一起跳坑。<a href="https://github.com/Yao544303/translation4pmml">github地址</a></li>
</ul>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>有中文名的，是已经翻译的部分。</p>
<h2 id="通用结构部分"><a href="#通用结构部分" class="headerlink" title="通用结构部分"></a>通用结构部分</h2><ul>
<li>Conformance</li>
<li>Interoperability</li>
<li>General Structure: PMML 基本结构</li>
<li>Field Scope</li>
<li>Header: 文件头</li>
<li>Data Dictionary: 数据字典</li>
<li>Mining Schema: 数据挖掘模式</li>
<li>Transformation Dictionary and Derived Fields: 数据转换操作和追加字段</li>
<li>Statistics</li>
<li>Taxonomies and Hierarchies</li>
<li>Target Fields and Values</li>
<li>Output fields</li>
<li>Definition and Application of Functions</li>
<li>Built-in functions</li>
<li>Model Verification</li>
<li>Model Expalnation</li>
<li>Multiple Models</li>
</ul>
<h2 id="模型部分"><a href="#模型部分" class="headerlink" title="模型部分"></a>模型部分</h2><ul>
<li>Association Rules</li>
<li>Baseline Models</li>
<li>Bayesian Network</li>
<li>Cluster Models</li>
<li>Gaussian Process</li>
<li>General Regression</li>
<li>k-Nearest Neighbors</li>
<li>Naive Bayes</li>
<li>Neural Network</li>
<li>Regression</li>
<li>Ruleset</li>
<li>Scorecard</li>
<li>Sequences</li>
<li>Text Models</li>
<li>Time Series</li>
<li>Trees </li>
<li>Vector Machine</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/discussWithDH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/02/discussWithDH/" class="post-title-link" itemprop="url">和DH大神的交流记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-02 23:54:26" itemprop="dateCreated datePublished" datetime="2018-07-02T23:54:26+08:00">2018-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-07-03 00:00:39" itemprop="dateModified" datetime="2018-07-03T00:00:39+08:00">2018-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="交流目的及解答"><a href="#交流目的及解答" class="headerlink" title="交流目的及解答"></a>交流目的及解答</h1><h2 id="反馈现在遇到的问题"><a href="#反馈现在遇到的问题" class="headerlink" title="反馈现在遇到的问题"></a>反馈现在遇到的问题</h2><p>获得解答</p>
<h2 id="确定后续的技术路线，借助DT的经验来确定选型是否合适"><a href="#确定后续的技术路线，借助DT的经验来确定选型是否合适" class="headerlink" title="确定后续的技术路线，借助DT的经验来确定选型是否合适"></a>确定后续的技术路线，借助DT的经验来确定选型是否合适</h2><p>之前定的方案是合适的，但是细节上需要进一步明确。</p>
<h2 id="得出能够落实的方案（理论依据-实现可能）"><a href="#得出能够落实的方案（理论依据-实现可能）" class="headerlink" title="得出能够落实的方案（理论依据 + 实现可能）"></a>得出能够落实的方案（理论依据 + 实现可能）</h2><ul>
<li>向业务请教现有有效规则经验，抽象化为特征</li>
<li>积累数据</li>
<li>模型迁移尝试</li>
<li>构建稀疏特征，第一步尝试使用MLR等传统模型处理，第二步采用多层神经网络（是否激进一些，直接使用神经网络？？？）</li>
</ul>
<h1 id="交流内容点"><a href="#交流内容点" class="headerlink" title="交流内容点"></a>交流内容点</h1><h2 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>是否进行异常值处理？</li>
<li>使用哪些异常处理的方式会更为合适？</li>
</ul>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li>尽量使用尊重数据本身，不要做异常值处理</li>
</ul>
<h2 id="特征构建及选择"><a href="#特征构建及选择" class="headerlink" title="特征构建及选择"></a>特征构建及选择</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>如何进行分段（离散化、分箱） ？</li>
<li>是否做哑变量处理？</li>
<li>如何进行选择(高度线性相关、近零方差、逐步迭代回归)？</li>
<li>扩展维度编码（是否一起编码） 做成插件形式？</li>
</ul>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><ul>
<li>通过业务的先验知识，增加强相关的特征</li>
<li>通过比较粗暴的方式，获取全量的特征（比如每个时间段的点击），然后通过多层神经网络（中间层加入特征选取的功能）进行筛选和预测</li>
<li>通过高次特征组合的方式，来扩展特征</li>
<li>尽量使用端到端的方式，进行特征选取</li>
<li>case1 人 品牌 交互行为 时间 ，以这个四个张量维度，作为基础，分别计算各个维度可能扩展出来的特征，从而扩展出数百个强关联的特征。例如人的年龄、性别。 品牌的价位，点击情况等等。</li>
<li>总结：尽可能多的选取特征，交给模型去筛选（注：为避免高阶特征可能出现的共线性问题，尽量选取抗共线性模型）</li>
</ul>
<h2 id="稀疏矩阵处理"><a href="#稀疏矩阵处理" class="headerlink" title="稀疏矩阵处理"></a>稀疏矩阵处理</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul>
<li>采用神经网络：技术选型 线下Keras 线上DL4J</li>
<li>采用GBDT +  LR</li>
<li>采用XGBoost</li>
</ul>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><ul>
<li>第一步可以使用MLR,GBM,XGBoost等</li>
<li>后续，构建多层神经网络（层之间，增加不同的特征处理手段）</li>
<li>采用流式学习的模型，可以考虑进行增量学习</li>
<li>调优经验：一方面是根据已有的经验（树的深度，分叉等等）进行调参，另一方面是通过grid search 搜索</li>
</ul>
<h2 id="数据非平衡-amp-数据提纯问题"><a href="#数据非平衡-amp-数据提纯问题" class="headerlink" title="数据非平衡  &amp;  数据提纯问题"></a>数据非平衡  &amp;  数据提纯问题</h2><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><ul>
<li>尽量尊重样本本身，不要对样本做过多的处理</li>
<li>case1 文本问题，4万样本，百万级别特征</li>
<li>case2 图像问题，3万样本</li>
<li>case3 CTR 问题，4亿样本，亿级别特征，正负样本1：80</li>
</ul>
<h2 id="关于推荐算法"><a href="#关于推荐算法" class="headerlink" title="关于推荐算法"></a>关于推荐算法</h2><h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><ul>
<li>可以尝试</li>
<li>无监督学习一般来说，难以超越有监督学习</li>
</ul>
<h2 id="关于模型迁移"><a href="#关于模型迁移" class="headerlink" title="关于模型迁移"></a>关于模型迁移</h2><p><strong>解答</strong></p>
<ul>
<li>相似类型业务的模型，可以迁移使用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/readnotes4june/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="喵十八">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵十八の小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/02/readnotes4june/" class="post-title-link" itemprop="url">201806读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-07-02 23:30:35 / Modified: 23:34:38" itemprop="dateCreated datePublished" datetime="2018-07-02T23:30:35+08:00">2018-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%80%E8%AF%AD/" itemprop="url" rel="index"><span itemprop="name">一语</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="“你有什么才华？”-“我会填坑”"><a href="#“你有什么才华？”-“我会填坑”" class="headerlink" title="“你有什么才华？” “我会填坑”"></a>“你有什么才华？” “我会填坑”</h1><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><p>感悟</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>你能走多远，取决于你填坑的能力有多大。你的填坑力，就是你了不起的才华。</li>
<li>天马行空是老板本色，能不能让它落地是你的实力。</li>
<li>摆正心态，解决问题。只有崎岖不平时，才能看出人与人之间的差距，有人被困住了，有人迈过去了。</li>
</ul>
<p><a href="http://www.sohu.com/a/233884337_661623">ref</a></p>
<h1 id="程序员，唯有锻炼与读书不能辜负"><a href="#程序员，唯有锻炼与读书不能辜负" class="headerlink" title="程序员，唯有锻炼与读书不能辜负"></a>程序员，唯有锻炼与读书不能辜负</h1><h2 id="类别-1"><a href="#类别-1" class="headerlink" title="类别"></a>类别</h2><p>鸡汤</p>
<h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><ul>
<li>不管长相如何，锻炼久了，减脂塑形，精力充沛，可以遇见全新的自己。</li>
<li>不论学历如何，读书多了，内心充实，精神丰富，腹有诗书气自华。</li>
</ul>
<h3 id="坚持跑步的效果："><a href="#坚持跑步的效果：" class="headerlink" title="坚持跑步的效果："></a>坚持跑步的效果：</h3><ol>
<li>越来越勤奋</li>
<li>抗压能力越来越强</li>
<li>会早起</li>
<li>魅力会增加</li>
</ol>
<h3 id="坚持读书的效果"><a href="#坚持读书的效果" class="headerlink" title="坚持读书的效果"></a>坚持读书的效果</h3><ol>
<li>刺激精神</li>
<li>减轻压力</li>
<li>提高记忆力</li>
<li>增强分析能力</li>
<li>提高写作技能</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/Acyi1VfbG96baVtFZVUOXA">ref</a></p>
<h1 id="小糖的一段微博"><a href="#小糖的一段微博" class="headerlink" title="小糖的一段微博"></a>小糖的一段微博</h1><h2 id="类别-2"><a href="#类别-2" class="headerlink" title="类别"></a>类别</h2><p>感悟</p>
<h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h2><p>三四年前去考试的时候住的姨姥姥家，老城区，大半夜坐的车，只记得成排的梧桐树和几乎照不亮的路灯。天太暗，车多，路特别难找，那段时间老人家一个人住，大半夜地跑出来接我们娘俩。她家就几十平米两间房，睡的木板床，家里泛着一股潮湿的陈醋味道。卫生间也小，晚上刷牙的时候一个水盆边儿站不下两个人。后来我们挤在一张床上，床挺大，褥子垫的老高。她肯定特想跟我妈说话，但后来就念叨着“娃娃明天考试”迷迷糊糊地打起了呼噜。早上四点她就爬起来给我们做饭，臊子面，老陕都知道这玩意准备工作多麻烦。我就这醋味和肉香，闷头睡到了六点。也不知道是不是因为她做得真的很好吃，早上那顿比平时吃的要多。后来她就送我到车站，车开了还一直跟着走。我妈说她热心肠，爱干活，年轻时候给厂子里扫地，每天都是四点起床。后来我们离开的时候，她还托我姨姥爷送了好多韭菜盒子。我还记得那堆饼子有多重，回到家的时候累得说不出话。再后来她打过几次电话来，都是找我姥姥，过年问个好。这些年去了好多次西安，但从来没去过她家。一直到上个月听说她住院，我妈和姥姥去看了，说刚做完手术，不舍得住院，一直在家休息。隔天早上又四点钟起来，做了一桌热腾腾的臊子面。得知她去世的消息时我还在看书，现在当然看不下去了，一个人坐在地板上敲字。好像不写点什么就会觉得更难受。我只见过她一次，就记得她长得和我姥姥很像，个子不高，爱笑。我还记得她家的红木衣柜，大红脸盆，还有散不去的陈醋香。我姨姥爷不喜欢做饭，下次去她家还能闻到这味道吗？我只知道不会再有人四点起来做臊子面，不会再有人拉着我的手帮我看手相，也不会再有人送一大袋子提不动的韭菜盒子给远道而来的亲人;我只知道我是个废物，为了一个只见过一面的老人泣不成声，却他妈连请个假跟她道别都做不到。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本来想写点什么，但发现再多感悟，在这真挚的流露前，不如无言。人生不易，且自珍惜。</p>
<h1 id="机器学习工程师是在打造数据科学界的万金油？"><a href="#机器学习工程师是在打造数据科学界的万金油？" class="headerlink" title="机器学习工程师是在打造数据科学界的万金油？"></a>机器学习工程师是在打造数据科学界的万金油？</h1><h2 id="类别-3"><a href="#类别-3" class="headerlink" title="类别"></a>类别</h2><p>经验</p>
<h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h2><ol>
<li>机器学习工程师技能要求广泛。</li>
<li>扮演着融合连接的角色。</li>
<li>将机器学习的算法抽象为方便调用的API</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>机器学习工程师应该做到以下几点：</p>
<ul>
<li>断言所有生产任务在实际执行和调度方面都能正常工作</li>
<li>勤用机器学习库，将机器学习库的作用发挥到极致，经常添加新的功能</li>
<li>确保数据代码具有可维护性、可扩展性和可调试性</li>
<li>自动化和抽象在大多数机器学习任务中存在的不同的、可重复的例程</li>
<li>为数据科学团队带来最好的软件开发实践，并帮助它们加速工作</li>
<li>与开发运营团队一起选择最佳运营架构</li>
<li>不断寻求性能提升，并确定在生产环境中使用哪种机器学习技术</li>
</ul>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>这个文章感触很深，因为自己现在做的就是这个工作。衔接着算法和工程。同时由于其他一些原因，事实上还承担着全流程责任人的角色。<br>说白了，既要写代码，也要研究算法，还得和业务沟通交流需求，制定计划。<br>开发语言也在Scala、Java、C++、Python、R、Excel、PPT中来回切换。可能理论公式推导到一半，就得帮人调bug。<br>全栈工程师，真是一份完美的工作啊！（呵呵哒）</p>
<p><a href="https://mp.weixin.qq.com/s/2lY_pcVnMs0JCW6DZTI3eA">ref</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">喵十八</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yao544303" title="GitHub → https://github.com/Yao544303" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yao544303963@gmail.com" title="E-Mail → mailto:yao544303963@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">喵十八</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
